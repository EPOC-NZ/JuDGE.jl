var documenterSearchIndex = {"docs":
[{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"EditURL = \"https://github.com/reganbaucke/JuDGE.jl/blob/master/docs/src/examples/02-knapsack-branch.jl\"","category":"page"},{"location":"examples/02-knapsack-branch/#Knapsack-Problem-Branch-and-Price","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"This example demonstrates how the branch and price algorithm can be used to solve a JuDGE model.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"using JuMP, JuDGE, GLPK, Random","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"We will randomly generate data for this problem, but to ensure a consistent result we first set the random seed.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Random.seed!(50)","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"We specify that there are 5 possible expansion investments, and 10 items to select from at each node.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"numinvest = 5\nnumitems = 10","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"The tree is defined to have a depth and 4 and a degree of 3.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"mytree = narytree(4,3)","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Find the number of nodes in the tree","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"totalnodes = JuDGE.count(mytree)","category":"page"},{"location":"examples/02-knapsack-branch/#Data","page":"Knapsack Problem - Branch and Price","title":"Data","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up the investment cost data","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"investcost = zeros(totalnodes,numinvest)\nfor i = 1:totalnodes\n  investcost[i,:] = ([1,1.8,3.5,6.8,13.5])*(1-((i-1)/(totalnodes*1.2)))\nend","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Specify the investment volumes using a binary expansion, with an initial capacity of 0","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"investvol = [1,2,4,8,16]\ninitialcap = 0","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Randomly specify the item volumes and costs","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"itemvolume = zeros(totalnodes,numitems)\nfor i = 1:totalnodes\n  itemvolume[i,:] = ((rand(numitems))*2) + collect(range(4,22,length = numitems))\nend\n\nitemcost = zeros(totalnodes,numitems)\nfor i = 1:totalnodes\n  itemcost[i,:] = ((rand(numitems) .- 0.5)*2)*2# + collect(range(0.5,1,length = numitems))\nend","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Create a function that maps the node, and data name to a value","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"nodes = collect(mytree)\nfunction data(node, input)\n  input[findall(x -> x == node, nodes)[1], :]\nend","category":"page"},{"location":"examples/02-knapsack-branch/#Subproblem-definitions","page":"Knapsack Problem - Branch and Price","title":"Subproblem definitions","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Define the subproblems as a function of the node","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"JuDGE_SP_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0, \"mip_gap\" => 0.0)\nfunction sub_problems(node)\n  model = Model(JuDGE_SP_Solver)\n  @expansion(model, bag[1:numinvest])\n  @expansioncosts(model, sum(data(node,investcost)[i] * bag[i] for i in  1:numinvest))\n  @variable(model, y[1:numitems], Bin)\n  @constraint(model, BagExtension ,sum( y[i]*data(node,itemvolume)[i] for i in 1:numitems) <=\n  \t\t\t\tinitialcap + sum(bag[i]*investvol[i] for i in 1:numinvest))\n  @sp_objective(model, sum(-data(node,itemcost)[i] * y[i] for i in 1:numitems))\n  model\nend","category":"page"},{"location":"examples/02-knapsack-branch/#Defining-and-solving-the-JuDGE-model","page":"Knapsack Problem - Branch and Price","title":"Defining and solving the JuDGE model","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up the JuDGE model.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"JuDGE_MP_Solver = optimizer_with_attributes((method=GLPK.INTERIOR) -> GLPK.Optimizer(),\n\t\t\t\t\t\t\t\"msg_lev\" => 0, \"mip_gap\" => 0.0)\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Solve the JuDGE model using the branch and price algorithm, using a constraint branch and branching on the lowest lower bound nodes first","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"best=JuDGE.branch_and_price(judy,rlx_abstol=10^-7,inttol=10^-6,\n\t\t\t\tbranch_method=JuDGE.constraint_branch,search=:lowestLB)","category":"page"},{"location":"examples/02-knapsack-branch/#Displaying-the-output","page":"Knapsack Problem - Branch and Price","title":"Displaying the output","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Print the objective function value","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"println(\"Objective: \"*string(best.bounds.UB))","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Create a custom function that formats the output for print_expansions(...), and print the expansions using this function","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"function format_output(s::Symbol,values)\n  if s==:bag\n\t return sum(values[i]*investvol[i] for i in 1:numinvest)\n  end\n  return nothing\nend\n\nJuDGE.print_expansions(best,format=format_output)","category":"page"},{"location":"examples/02-knapsack-branch/#Deterministic-equivalent","page":"Knapsack Problem - Branch and Price","title":"Deterministic equivalent","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up and solve the deterministic equivalent problem","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"JuDGE_DE_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 2, \"mip_gap\" => 3)\ndeteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)\nprintln(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#AbstractTree-Functions","page":"API Reference","title":"AbstractTree Functions","text":"","category":"section"},{"location":"api/#Defining-Trees","page":"API Reference","title":"Defining Trees","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.narytree\nJuDGE.tree_from_file\nJuDGE.tree_from_leaves\nJuDGE.print_tree","category":"page"},{"location":"api/#JuDGE.narytree","page":"API Reference","title":"JuDGE.narytree","text":"narytree(depth::Int64, degree::Int64)\n\nGiven the depth and degree, this function returns an N-ary tree. Note that a depth of 0 return a single Leaf node (which is also the root node of the tree).\n\nRequired Arguments\n\ndepth is the maximum number of arcs from the root node any Leaf node\n\ndegree is the number of children of all nodes, other than the Leaf nodes\n\nExample\n\ntree = narytree(2,2)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.tree_from_file","page":"API Reference","title":"JuDGE.tree_from_file","text":"tree_from_file(filename::String)\n\nConstruct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node \"A\" to node \"B\". The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the data. Each column itself converted into a dictionary, indexed by the node.\n\nRequired Arguments\n\nstring is the full path of the file containing the tree\n\nExample\n\ntree, data = tree_from_file(joinpath(@__DIR__,\"tree.csv\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.tree_from_leaves","page":"API Reference","title":"JuDGE.tree_from_leaves","text":"tree_from_leaves(leafnodes::Array{Array{Int64,1},1}, probs::Array{Float64,1})\n\nConstruct tree from Array of leaf nodes, and (optionally) the corresponding probabilities\n\nRequired Arguments\n\nleafnodes is an array of arrays defining the set of leaf nodes\n\nOptional Arguments\n\nprobs is an array of probabilities for the leaf nodes\n\nExample\n\n(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])\ntree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.print_tree","page":"API Reference","title":"JuDGE.print_tree","text":"print_tree(some_tree::AbstractTree, data::T where T <: Dict)\n\nGiven some_tree, this function prints a simple representation of the tree to the REPL.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise\n\nOptional Arguments\n\ndata is a dictionary indexed by the nodes of some_tree\n\n\n\n\n\n","category":"function"},{"location":"api/#Nodes-of-Trees","page":"API Reference","title":"Nodes of Trees","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Base.collect\nJuDGE.get_leafnodes\nJuDGE.get_node","category":"page"},{"location":"api/#Base.collect","page":"API Reference","title":"Base.collect","text":"collect(tree::Tree;order=:depth)\n\nGiven tree, this function returns an array of corresponding nodes. By default this will be in a depth-first order.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect the nodes\n\nOptional Arguments\n\norder can be set to :depth or :breadth to specify the order that the nodes are listed in the array.\n\nExamples\n\nnodes = collect(tree) #gets an array of nodes from tree in depth-first order\nnodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_leafnodes","page":"API Reference","title":"JuDGE.get_leafnodes","text":"get_leafnodes(tree::AbstractTree)\n\nGiven tree, this function returns an array of corresponding Leaf nodes.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect leaf nodes\n\nExample\n\nleafnodes = JuDGE.get_leafnodes(tree) #define a function that returns the parent of each node in the tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_node","page":"API Reference","title":"JuDGE.get_node","text":"get_node(tree::AbstractTree, indices::Array{Int64,1})\n\nGiven a tree, and an array of indices, this function returns the corresponding node in the tree.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nindicies is an array of integer indices identifying a node within tree.\n\nExamples\n\nnode = get_node(tree,[1]) #get the root node\nnode = get_node(tree,[1,1]) #get the first child of the root node\nnode = get_node(tree,[1,2]) #get the second child of the root node\n\n\n\n\n\n","category":"function"},{"location":"api/#Tree-Probabilities","page":"API Reference","title":"Tree Probabilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.convert_probabilities\nJuDGE.ConditionallyUniformProbabilities\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"api/#JuDGE.convert_probabilities","page":"API Reference","title":"JuDGE.convert_probabilities","text":"convert_probabilities(tree::AbstractTree, probabilities::Dict{AbstractTree,Float64})\n\nGiven a dictionary of conditional probabilities for each node in tree, this function returns a dictionary that maps each node of tree to the corresponding unconditional probability.\n\nRequired Arguments\n\ntree is the tree that the probabilities pertain to\n\nprobabilities is a dictionary of condition probabilities for each node in tree\n\nExample\n\nprobs = JuDGE.convert_probabilities(tree,probabilities)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.ConditionallyUniformProbabilities","page":"API Reference","title":"JuDGE.ConditionallyUniformProbabilities","text":"ConditionallyUniformProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = ConditionallyUniformProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.UniformLeafProbabilities","page":"API Reference","title":"JuDGE.UniformLeafProbabilities","text":"UniformLeafProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = UniformLeafProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-Tree-functions","page":"API Reference","title":"Other Tree functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.depth\nJuDGE.history\nJuDGE.parent_builder","category":"page"},{"location":"api/#JuDGE.depth","page":"API Reference","title":"JuDGE.depth","text":"depth(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's depth. The root node has a depth of 0.\n\nRequired Arguments\n\ntree is the tree that the depth function will correspond to.\n\nExample\n\ndepth_fn = JuDGE.depth(tree) #define a function that returns the depth of each node in the tree\ndpth = depth_fn(node) #get the depth of node in tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.history","page":"API Reference","title":"JuDGE.history","text":"history(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\nhistory_fn = JuDGE.history(tree) #define a function that returns the history of each node in the tree\n\npast = history_fn(node) #get a vector of nodes that precede node in tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.parent_builder","page":"API Reference","title":"JuDGE.parent_builder","text":"parent_builder(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's parent.\n\nRequired Arguments\n\ntree is the tree that the parent function will correspond to.\n\nExample\n\nparent_fn = JuDGE.parent_builder(tree) #define a function that returns the parent of each node in the tree\np = parent_fn(node) #get the parent of node\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE-Functions","page":"API Reference","title":"JuDGE Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.JuDGEModel\nJuDGE.solve(::JuDGEModel)\nJuDGE.branch_and_price\nJuDGE.constraint_branch\nJuDGE.resolve_subproblems","category":"page"},{"location":"api/#JuDGE.JuDGEModel","page":"API Reference","title":"JuDGE.JuDGEModel","text":"JuDGEModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor::Float64,\n           CVaR::Tuple{Float64,Float64},\n           sideconstraints)\n\nDefine a JuDGE model.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nCVaR is a tuple with the two CVaR parameters: (λ, β)\n\nsideconstraints is a function which specifies side constraints in the master problem, see example * for further details.\n\nExamples\n\njudge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, CVaR=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.solve-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(judge::JuDGEModel;\n      abstol = 10^-14,\n      reltol = 10^-14,\n      rlx_abstol = 10^-14,\n      rlx_reltol = 10^-14,\n      duration = Inf,\n      iter = 2^63 - 1,\n      inttol = 10^-9,\n      allow_frac = 0,\n      prune = Inf)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nabstol is the absolute tolerance for the best integer-feasible objective value and the lower bound\n\nreltol is the relative tolerance for the best integer-feasible objective value and the lower bound\n\nrlx_abstol is the absolute tolerance for the relaxed master objective value and the lower bound\n\nrlx_reltol is Set the relative tolerance for the relaxed master objective value and the lower bound\n\nduration is the maximum duration\n\niter is the maximum number of iterations\n\ninttol is the maximum deviation from 0 or 1 for integer feasible solutions\n\nUsed by the branch and price algorithm\n\nallow_frac indicates wheither a fractional solution will be returned\n\nprune is used to stop the algorithm before convergence, if a known upper bound for the problem is specified\n\nExamples\n\nJuDGE.solve(jmodel, rlx_abstol=10^-6)\nJuDGE.solve(jmodel, abstol=10^-6)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.branch_and_price","page":"API Reference","title":"JuDGE.branch_and_price","text":"branch_and_price(judge::JuDGEModel;\n\t  branch_method=JuDGE.constraint_branch,\n\t  search=:depth_first_resurface,\n      abstol = 10^-14,\n      reltol = 10^-14,\n      rlx_abstol = 10^-14,\n      rlx_reltol = 10^-14,\n      duration = Inf,\n      iter = 2^63 - 1,\n      inttol = 10^-9)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nbranch_method specifies the way that constrants are added to create node nodes\n\nsearch specifies the order in which nodes are solved in the (brnach-and-price) tree\n\nabstol is the absolute tolerance for the best integer-feasible objective value and the lower bound\n\nreltol is the relative tolerance for the best integer-feasible objective value and the lower bound\n\nrlx_abstol is the absolute tolerance for the relaxed master objective value and the lower bound\n\nrlx_reltol is Set the relative tolerance for the relaxed master objective value and the lower bound\n\nduration is the maximum duration\n\niter is the maximum number of iterations\n\ninttol is the maximum deviation from 0 or 1 for integer feasible solutions\n\nExamples\n\nJuDGE.branch_and_price(jmodel, abstol=10^-6)\nJuDGE.branch_and_price(jmodel, branch_method=JuDGE.variable_branch, search=:lowestLB)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.constraint_branch","page":"API Reference","title":"JuDGE.constraint_branch","text":"constraint_branch(master, tree, expansions, inttol)\n\nThis is an in-built function that is called during branch-and-price to perform a branch. Users can define their own functions that follow this format to create new branching strategies.\n\nRequired Arguments\n\nmaster is the master problem of the JuDGE model\n\ntree is the tree of the JuDGE model\n\nexpansions is a dictionary of capacity expansion variables, indexed by node.\n\ninttol is the maximum permitted deviation from 0 or 1 for a value to still be considered binary.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.resolve_subproblems","page":"API Reference","title":"JuDGE.resolve_subproblems","text":"resolve_subproblems(judge::JuDGEModel)\n\nOnce a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.\n\nRequired Arguments\n\njmodel is the JuDGE model that we wish to solve.\n\nExamples\n\nresolve_subproblems(judge)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE-macros-for-subproblems","page":"API Reference","title":"JuDGE macros for subproblems","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.@expansion\nJuDGE.@shutdown\nJuDGE.@expansioncosts\nJuDGE.@maintenancecosts\nJuDGE.@sp_objective","category":"page"},{"location":"api/#JuDGE.@expansion","page":"API Reference","title":"JuDGE.@expansion","text":"expansion(model, variable, lag, span)\n\nDefines an expansion variable variable within a subproblem model. Note that all subproblems must have the same set of expansion variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available\n\nspan is the number of consecutive nodes in the scenario over which an expansion is available\n\nExamples\n\n@expansion(model, expand[1:5]) #defines an array of 5 variables with no lag, and unlimited lifespan\n@expansion(model, expand[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited lifespan\n@expansion(model, expand, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@shutdown","page":"API Reference","title":"JuDGE.@shutdown","text":"shutdown(model, variable, lag, span)\n\nDefines an shutdown variable variable within a subproblem model. Note that all subproblems must have the same set of shutdown variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the shutdown variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable\n\nspan is the number of consecutive nodes in the scenario over which the shutdown will last\n\nExamples\n\n@shutdown(model, shut[1:5]) #defines an array of 5 variables with no lag, and unlimited duration\n@shutdown(model, shut[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited duration\n@shutdown(model, shut, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@expansioncosts","page":"API Reference","title":"JuDGE.@expansioncosts","text":"expansioncosts(model, expr)\n\nDefines a linear expression specifying the cost of expansions and shutdowns at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the total cost of choosing expansion and shutdown variables at the current node\n\nExample\n\n@expansioncosts(model, sum(expand[i]*cost[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@maintenancecosts","page":"API Reference","title":"JuDGE.@maintenancecosts","text":"maintenancecosts(model, expr)\n\nDefines a linear expression specifying the ongoing cost of expansions and shutdowns available at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the ongoing cost of expansions and shutdowns available at the current node\n\nExample\n\n@maintenancecosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@sp_objective","page":"API Reference","title":"JuDGE.@sp_objective","text":"sp_objective(model, expr)\n\nDefines a linear expression specifying the cost of operating the system for the current node, excluding expansion or ongoing costs.\n\nIf it's possible to avoid costs by not using some previously expanded capacity, this can be included here with by directly including the expansion variable in the expression.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the subproblem costs.\n\nExample\n\n@sp_objective(model, sum(y[i]*c[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE-Output","page":"API Reference","title":"JuDGE Output","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.write_solution_to_file(::JuDGEModel,::String)\nJuDGE.print_expansions(::JuDGEModel)","category":"page"},{"location":"api/#JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(jmodel::JuDGEModel,filename::String)\n\nGiven a JuDGE model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.print_expansions-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(jmodel::JuDGEModel;\n                onlynonzero::Bool=true,\n                inttol=10^-9,\n                format=nothing)\n\nGiven a solved JuDGE model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See the examples for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Deterministic-Equivalent","page":"API Reference","title":"Deterministic Equivalent","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.DetEqModel\nJuDGE.solve(::DetEqModel)","category":"page"},{"location":"api/#JuDGE.DetEqModel","page":"API Reference","title":"JuDGE.DetEqModel","text":"DetEqModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor::Float64,\n           CVaR::Tuple{Float64,Float64},\n           sideconstraints)\n\nDefine a deterministic equivalent model for the stochastic capacity expansion problem.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for this problem (with appropriate settings)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nCVaR is a tuple with the two CVaR parameters: (λ, β)\n\nsideconstraints is a function which specifies side constraints in the master problem, see example * for further details.\n\nExamples\n\ndeteq = DetEqModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = DetEqModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, CVaR=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.solve-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(deteq::DetEqModel)\n\nSolve a determinisitc equivalent model.\n\nRequired Arguments\n\ndeteq is the determinisitc equivalent model that we wish to solve.\n\nExample\n\nJuDGE.solve(deteq)\n\n\n\n\n\n","category":"method"},{"location":"api/#Deterministic-Equivalent-Output","page":"API Reference","title":"Deterministic Equivalent Output","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.write_solution_to_file(::DetEqModel,::String)\nJuDGE.print_expansions(::DetEqModel)","category":"page"},{"location":"api/#JuDGE.write_solution_to_file-Tuple{DetEqModel,String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(deteq::DetEqModel,filename::String)\n\nGiven a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.print_expansions-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(deteq::DetEqModel;\n                onlynonzero::Bool=true,\n                inttol=10^-9,\n                format=nothing)\n\nGiven a solved deterministic equivalent model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See the examples for more details.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Tutorial-1:-A-basic-JuDGE-model","page":"Tutorials","title":"Tutorial 1: A basic JuDGE model","text":"","category":"section"},{"location":"tutorials/#Problem-description","page":"Tutorials","title":"Problem description","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For our tutorial, we will consider the following optimization problem: Our goal is minimize the cost of a stochastic sequence of knapsack problems. We represent the stochastic process with a discrete scenario tree. At each node in the scenario tree, we solve a knapsack problem. However at any point in the tree, we have the ability to expand the capacity of our knapsack at a certain cost. Once the capacity of our bag has been expanded, we are able use the extra volume for future knapsack problems from this node of the tree forward.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"In this optimization problem, we are trading off against the cost of expanding our knapsack, versus the ability to fit more into our knapsack. Deciding when to perform the knapsack expansion is the difficult part of this optimization problem.","category":"page"},{"location":"tutorials/#Solving-our-problem-using-JuDGE","page":"Tutorials","title":"Solving our problem using JuDGE","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"First things first, we should bring into our workspace JuDGE, JuMP, and Gurobi using","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using JuDGE\nusing JuMP\nusing GLPK","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Using these libraries, we will now model and solve our optimization problem.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The lifecycle of a JuDGEModel is the following:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The definition of a JuDGETree;\ndefining the subproblems of the JuDGEModel;\nbuilding the JuDGEModel;\nsolving the JuDGEModel.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The user's job is both Steps 1 and 2, while JuDGE will automatically perform Steps 3 and 4.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"A JuDGETree can be built in many different ways. A JuDGETree simply consists of the root node of the tree, and a list of all the nodes in the tree. This is defined as a nested set of subtrees, with the final nodes being leaf nodes. Each subtree simply defines its children, and there are functions that facilitate the calculation of its parent and the probability of arriving at the node, and the data that correspondes to the node, can be referenced through dictionaries.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For now, we will build a tree of depth 3, where each node has 2 children with uniform probabilities using buildtree:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mytree = narytree(2,2)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"mytree is a tree which contains 7 nodes, with depth 2, and degree 2. (A depth of 0, gives only a single leaf node.) We can visualise the tree using","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.print_tree(mytree)","category":"page"},{"location":"tutorials/#Problem-data","page":"Tutorials","title":"Problem data","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let us now associate our tree with the problem data.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"For our instance of the problem, we will use the following data: for each node, we will have a knapsack problem with three items to choose from, each with different rewards, and different volumes. The structure of this data is arbitrary; JuDGE just needs to be able to access the relevant data, based on the node being processed (dictionaries or functions are recommended).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"invest_cost = Dict( zip( collect(mytree,order=:breadth), [15, 8, 8, 4, 4, 4, 4]) )\n\n\nitem_volume = Dict( zip( collect(mytree,order=:breadth), [ [4, 3, 3, 1, 2],\n                                                         [5, 3, 4, 2, 1],\n                                                         [5, 4, 2, 7, 2],\n                                                         [5, 4, 1, 8, 2],\n                                                         [3, 1, 5, 6, 3],\n                                                         [2, 5, 8, 4, 6],\n                                                         [7, 5, 4, 2, 3] ]) )\n\nitem_reward = Dict( zip( collect(mytree,order=:breadth), [ [32, 9, 9, 4, 8],\n                                                         [30, 12, 40, 10, 9],\n                                                         [20, 28, 12, 42, 12],\n                                                         [40, 28, 9, 24, 10],\n                                                         [15, 7, 20, 48, 12],\n                                                          [10, 30, 54, 32, 30],\n                                                         [32, 25, 24, 14, 24] ]) )","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can print the tree again and display a parameter for each node:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.print_tree(mytree,item_reward)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We also define some other parameters that apply to all the nodes.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"num_items=5\nnum_invest=6\ninitial_volume = 6\ninvest_volume = [2,2,2,3,3,3]","category":"page"},{"location":"tutorials/#Subproblems","page":"Tutorials","title":"Subproblems","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We need to now define the subproblems. These are JuMP models with some JuDGE- specific features. For our knapsack problem:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE_SP_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0, \"mip_gap\" => 0.0)\nfunction sub_problems(node)\n   sp = Model(JuDGE_SP_Solver)\n   @expansion(sp, invest[1:num_invest])\n   @expansioncosts(sp, sum(invest[i]*invest_volume[i] for i=1:num_invest)*invest_cost[node])\n   @variable(sp, y[1:num_items], Bin)\n   @constraint(sp, BagExtension, sum(y[i]*item_volume[node][i] for i in 1:num_items) <=\n        initial_volume + sum(invest_volume[i] * invest[i] for i in 1:num_invest))\n   @sp_objective(sp, sum(-item_reward[node][i] * y[i] for i in 1:num_items))\n   return sp\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The three elements of this that make it a JuDGE subproblem are:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansion(model, bag) This defines the expansion variables, and supports standard JuMP vectorized variable declaration. These will be binary.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansioncosts This declares an expression for the costs of investment; this must be linear (an AffExpr).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The overall optimization problem at each node problem is a classical knapsack problem. We have hard-coded that the initial volume of the knapsack is 3, and the investment in the bag increases it by 4.","category":"page"},{"location":"tutorials/#Solving-the-JuDGE-Model","page":"Tutorials","title":"Solving the JuDGE Model","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Now with our tree built and the problem data referenced, we can initialize the JuDGEModel based on our tree, subproblems, and solver.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE_MP_Solver = optimizer_with_attributes((method=GLPK.INTERIOR) -> GLPK.Optimizer(),\n\t\t\t\t\t\t\t\"msg_lev\" => 0, \"mip_gap\" => 0.0)\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"ConditionallyUniformProbabilities simply applies a uniform conditional probability distribution for child nodes. Any function mapping nodes to absolute probabilities can be used here.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"At this point, we have now constructed a valid JuDGEModel. We can now solve our model by making a call to JuDGE.solve:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE.solve(judy)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are a number of optional stopping critieria that can be set here:     abstol, reltol, rlx_abstol, rlx_reltol, duration, iter.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Currently, we recommend using JuDGE with Gurobi as the subproblem and master problem solvers. Any solvers can be specified, but the master problem must return duals, and a barrier method is recommended to computational efficiency. The subproblems can be solved with any method, but currently need to be solved to optimality (bound gap of 0).","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can view the optimal solution to our problem by calling","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"println(\"Objective: \"*string(judy.bounds.UB))\nJuDGE.print_expansions(judy)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Finally, if we want to recover the optimal solutions for the nodes, we must fix the investments and resolve each subproblem, after which we can write the solution to a CSV file.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"println(\"Re-solved Objective: \" * string(resolve_subproblems(judy)))\nJuDGE.write_solution_to_file(judy,joinpath(@__DIR__,\"knapsack_solution.csv\"))","category":"page"},{"location":"tutorials/#Tutorial-2:-Formatting-output","page":"Tutorials","title":"Tutorial 2: Formatting output","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Since the expansion variables are all binary, the print_expansions function doesn't directly convey how much capacity is built. In order to output more information about the capacity it's possible to write a custom function that is supplied as an optional argument format. First, let us simply provide the capacity associated with each decision.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function format_output(s::Symbol,value)\n   if s==:invest\n      output=Dict{Int64,Float64}()\n      for i in 1:num_invest\n         output[i]=invest_volume[i]*value[i]\n      end\n\t  return output\n   end\n   return nothing\nend\n\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We can also aggregate the capacities of all the expansions.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function format_output(s::Symbol,value)\n   if s==:invest\n\t  return sum(invest_volume[i]*value[i] for i in 1:num_invest)\n   end\n   return nothing\nend\n\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/#Tutorial-3:-Deterministic-equivalent","page":"Tutorials","title":"Tutorial 3: Deterministic equivalent","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE can use the tree, and subproblems to automatically construct the deterministic equivalent of the stochastic capacity expansion problem. This is created by defining a DetEqModel with the same arguments as a JuDGEModel, as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE_DE_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 2, \"mip_gap\" => 0)\ndeteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The solution can be printed to the REPL or a CSV in the same way as a JUDGEModel.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"println(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))\nJuDGE.print_expansions(deteq, format=format_output)\nJuDGE.write_solution_to_file(judy,joinpath(@__DIR__,\"knapsack_solution.csv\"))","category":"page"},{"location":"tutorials/#Tutorial-4:-Lag-and-duration","page":"Tutorials","title":"Tutorial 4: Lag and duration","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Depending on the particular expansion problem being modelled, there may be some delay (lag) between when the expansion decision is made, and when the capacity becomes available. This can be modelled in JuDGE be specifying a lag when defining the expansion variables in the subproblems, the @expansion marco is overloaded to allow an additional argument which is an integer specifying the lag, e.g. for a lag of one you would define the expansion variables as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansion(sp, invest[1:num_invest],1)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"The duration of an expansion is set to ∞ by default. However, if an expansion is temporary or otherwise has a limited lifespan, we can include an additional argument we defining the expansion variable. For example if the lag is 0 and the duration is 2, we can define it as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"@expansion(sp, invest[1:num_invest],0,2)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We will now redefine our subproblems and re-solve our model. (Note that the invest_cost has been divided by 2.)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function sub_problems_lag(node)\n   sp = Model(JuDGE_SP_Solver)\n   @expansion(sp, invest[1:num_invest],1)\n   @expansioncosts(sp, sum(invest[i]*invest_volume[i] for i=1:num_invest)*invest_cost[node]/2)\n   @variable(sp, y[1:num_items], Bin)\n   @constraint(sp, BagExtension, sum(y[i]*item_volume[node][i] for i in 1:num_items) <=\n        initial_volume + sum(invest_volume[i] * invest[i] for i in 1:num_invest))\n   @sp_objective(sp, sum(-item_reward[node][i] * y[i] for i in 1:num_items))\n   return sp\nend\n\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems_lag, JuDGE_MP_Solver)\nJuDGE.solve(judy)\n\nprintln(\"Objective: \"*string(judy.bounds.UB))\nprintln(\"Lower Bound: \"*string(judy.bounds.LB))\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We see that although this solution has ostensibly converged, the best integer is greater than the lower bound. The * in the final line of the output means that the integer solution has been found using a MIP solve for the generated columns. In order to find a provably optimal solution we must use branch and price.","category":"page"},{"location":"tutorials/#Tutorial-5:-Branch-and-Price","page":"Tutorials","title":"Tutorial 5: Branch and Price","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE implements a branch and price algorithm for problems which are not naturally integer. It can be run with default settings as follows:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems_lag, JuDGE_MP_Solver)\nbest = JuDGE.branch_and_price(judy,search=:lowestLB,branch_method=JuDGE.constraint_branch)\n\nprintln(\"Objective: \"*string(best.bounds.UB))\nprintln(\"Lower Bound: \"*string(best.bounds.LB))\nJuDGE.print_expansions(best, format=format_output)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We now see that we have found a better solution, and proved it is optimal.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are several options for the search: :lowestLB always chooses to branch on the node with the lowest lower bound; :depth_first_dive performs a depth-first search of the branch and bound tree, once it find a node with an integer relaxation it keeps adjacent nodes within the tree; :depth_first_resurface performs a depth-first search of the branch and bound tree, but once it find a node with an integer relaxation it returns to the root node and explores the other branch; :breadth_first performs a breadth-first search of the tree.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"There are two built-in branching methods: JuDGE.constraint_branch and JuDGE.variable_branch. It is also possible to write custom branching methods; see the API for more details.","category":"page"},{"location":"tutorials/#Tutorial-6:-Side-constraints","page":"Tutorials","title":"Tutorial 6: Side-constraints","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"JuDGE supports side-constraints being added to the master problem. These can be constraints across expansion variables at a single node, or can be constraints on variables corresponding to different nodes. The JuDGE.history function can be useful if applying logical constraints on expansion variables. In order to apply a budget constraint at each node we can define the following function:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"function budget(model,tree)\n   for node in collect(tree)\n      @constraint(model,sum(invest_cost[node]*invest_volume[i]*invest[node][i]\n\t\t  for i in 1:num_invest)<=40)\n   end\nend","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"We now can define a JuDGEModel with these side-constraints, and solve it using branch and price.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver, sideconstraints=budget)\njudy = JuDGE.branch_and_price(judy,search=:lowestLB,branch_method=JuDGE.constraint_branch)\nJuDGE.print_expansions(judy, format=format_output)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"EditURL = \"https://github.com/reganbaucke/JuDGE.jl/blob/master/docs/src/examples/01-knapsack-1bag.jl\"","category":"page"},{"location":"examples/01-knapsack-1bag/#Knapsack-Problem-Single-Expansion","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This first example demonstrates how a basic JuDGE model can be set up, with a 7-node tree, and a single expansion.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"using JuMP, JuDGE, GLPK","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"First we will define our tree with a depth of 2 and a degree of 2.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"mytree = narytree(2,2)","category":"page"},{"location":"examples/01-knapsack-1bag/#Data","page":"Knapsack Problem - Single Expansion","title":"Data","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Now we specify data for each node of the tree. Here we define the data using functions, but you could use dictionaries, as shown in subsequent examples.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"function invest_cost(node)\n   if node == get_node(mytree,[1])\n\t  180.0\n   elseif node == get_node(mytree,[1,1])\n\t  50.0\n   elseif node == get_node(mytree,[1,2])\n\t  60.0\n   elseif node == get_node(mytree,[1,1,1])\n\t  40.0\n   elseif node == get_node(mytree,[1,1,2])\n\t  60.0\n   elseif node == get_node(mytree,[1,2,1])\n\t  10.0\n   elseif node == get_node(mytree,[1,2,2])\n\t  10.0\n   end\nend\n\nfunction item_volume(node)\n   if node == get_node(mytree,[1])\n\t  [6, 2, 1, 1, 1]\n   elseif node == get_node(mytree,[1,1])\n\t  [8, 2, 2, 2, 1]\n   elseif node == get_node(mytree,[1,2])\n\t  [8, 1, 1, 1, 3]\n   elseif node == get_node(mytree,[1,1,1])\n\t  [4, 4, 3, 1, 2]\n   elseif node == get_node(mytree,[1,1,2])\n\t  [1, 3, 1, 1, 2]\n   elseif node == get_node(mytree,[1,2,1])\n\t  [7, 3, 1, 1, 1]\n   elseif node == get_node(mytree,[1,2,2])\n\t  [2, 5, 2, 1, 2]\n   end\nend\n\nfunction item_reward(node)\n   if node == get_node(mytree,[1])\n\t  [60, 20, 10, 15, 10]\n   elseif node == get_node(mytree,[1,1])\n\t  [8, 10, 20, 20, 10]\n   elseif node == get_node(mytree,[1,2])\n\t  [8, 10, 15, 10, 30]\n   elseif node == get_node(mytree,[1,1,1])\n\t  [40, 40, 35, 10, 20]\n   elseif node == get_node(mytree,[1,1,2])\n\t  [15, 35, 15, 15, 20]\n   elseif node == get_node(mytree,[1,2,1])\n\t  [70, 30, 15, 15, 10]\n   elseif node == get_node(mytree,[1,2,2])\n\t  [25, 50, 25, 15, 20]\n   end\nend","category":"page"},{"location":"examples/01-knapsack-1bag/#Subproblem-definitions","page":"Knapsack Problem - Single Expansion","title":"Subproblem definitions","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"The JuDGE subproblems are defined through a function that takes a node as its single argument, returning a JuMP model. We use GLPK as our optimizer.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE_SP_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0, \"mip_gap\" => 0.0)\nfunction sub_problems(node)\n   model = Model(JuDGE_SP_Solver)\n   @expansion(model, bag)\n   @expansioncosts(model, bag*invest_cost(node))\n   @variable(model, y[1:5], Bin)\n   @constraint(model, BagExtension, sum(y[i]*item_volume(node)[i] for i in 1:5) <= 3 + 4 * bag)\n   @sp_objective(model, sum(-item_reward(node)[i] * y[i] for i in 1:5))\n   model\nend","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Note that there are a few JuDGE-specific macros used to define a JuDGE subproblem","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This defines our single expansion variable","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@expansion(model, bag)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This defines the cost of buying this bag at particular node","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@expansioncosts(model, bag*invest_cost(node))","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Instead of using @objective, JuDGE models use:","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@sp_objective(model, sum(-item_reward(node)[i] * y[i] for i in 1:5))","category":"page"},{"location":"examples/01-knapsack-1bag/#Defining-and-solving-the-JuDGE-model","page":"Knapsack Problem - Single Expansion","title":"Defining and solving the JuDGE model","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"The JuDGEModel is defined based on a tree, probability distribution, sub_problems, and an optimizer using an interior point method.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE_MP_Solver = optimizer_with_attributes((method=GLPK.INTERIOR) -> GLPK.Optimizer(),\n\t\t\t\t\t\t\t\"msg_lev\" => 0, \"mip_gap\" => 0.0)\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Solve the model","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE.solve(judy)","category":"page"},{"location":"examples/01-knapsack-1bag/#Displaying-the-output","page":"Knapsack Problem - Single Expansion","title":"Displaying the output","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Print the objective, and optimal expansions","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"println(\"Objective: \"*string(judy.bounds.UB))\nJuDGE.print_expansions(judy,onlynonzero=false)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Re-solve the subproblems and print the objective","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"println(\"Re-solved Objective: \" * string(resolve_subproblems(judy)))","category":"page"},{"location":"examples/01-knapsack-1bag/#Deterministic-equivalent","page":"Knapsack Problem - Single Expansion","title":"Deterministic equivalent","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Here we set up and solve the deterministic equivalent, this uses the same structure as a JuDGEModel. We set up our GLPK solver to show its progress.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE_DE_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 2, \"mip_gap\" => 0.0)\ndeteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)\nprintln(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tree/#AbstractTree-API","page":"AbstractTree API","title":"AbstractTree API","text":"","category":"section"},{"location":"tree/#Defining-Trees","page":"AbstractTree API","title":"Defining Trees","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.narytree\nJuDGE.tree_from_file\nJuDGE.tree_from_leaves\nJuDGE.print_tree","category":"page"},{"location":"tree/#Nodes-of-Trees","page":"AbstractTree API","title":"Nodes of Trees","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"Base.collect\nJuDGE.get_leafnodes\nJuDGE.get_node","category":"page"},{"location":"tree/#Tree-Probabilities","page":"AbstractTree API","title":"Tree Probabilities","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.convert_probabilities\nJuDGE.ConditionallyUniformProbabilities\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"tree/#Other-Tree-functions","page":"AbstractTree API","title":"Other Tree functions","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.depth\nJuDGE.history\nJuDGE.parent_builder","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"CurrentModule = JuDGE\nDocTestSetup = quote\n    using JuDGE\nend","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"(Image: JuDGE)","category":"page"},{"location":"#JuDGE","page":"JuDGE","title":"JuDGE","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE stands for: Julia Decomposition for General Expansion. Functionally, it is a solver which leverages the syntax of the JuMP modelling language to solve a particular class of optimisation problems.","category":"page"},{"location":"#Problem-Class-/-Decomposition","page":"JuDGE","title":"Problem Class / Decomposition","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE solves multi-stage stochastic integer programming problems using Dantzig-Wolfe decomposition. The user must specify a tree that represents the uncertainty of the problem, and at each node define a subproblem that can be a linear or integer program. Further, the expansion variables which link the subproblems must be declared.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE automatically generates a master problem and performs column generation to converge to an optimal solution.","category":"page"},{"location":"#Requirements","page":"JuDGE","title":"Requirements","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE requires Julia-1.3+, JuMP and appropriate optimiser(s). For academics, Gurobi / CPLEX provide free academic licenses, otherwise, you can use CBC/Clp or GLPK.","category":"page"},{"location":"#Installation","page":"JuDGE","title":"Installation","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is installed by the Pkg utility provided by Julia. In the Julia REPL, simply make the following function call.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"] add \"https://github.com/reganbaucke/JuDGE.jl\"","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Then, in your Julia script, use","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"using JuDGE","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"to import the functions from the JuDGE module into the current namespace.","category":"page"},{"location":"#Stochastic-Knapsack-Example","page":"JuDGE","title":"Stochastic Knapsack Example","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is distributed with an example of a multi-stage stochastic integer programming problem. This is a stochastic knapsack problem with investment. The file knapsack.jl contains the implementation of this problem within the JuDGE framework. There are also a number of variants of this model demonstrating other features of JuDGE.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"See the examples for details about this.","category":"page"},{"location":"#Limitations","page":"JuDGE","title":"Limitations","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"For each expansion variable, there can only be one expansion (i.e. variable is binary).\nSupport for decisions to reduce capacity is not fully tested.","category":"page"},{"location":"#Bugs","page":"JuDGE","title":"Bugs","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Please raise an issue if you experience an error while using JuDGE.","category":"page"}]
}
