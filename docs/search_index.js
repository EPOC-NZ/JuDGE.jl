var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#AbstractTree-Functions","page":"API Reference","title":"AbstractTree Functions","text":"","category":"section"},{"location":"api/#Defining-Trees","page":"API Reference","title":"Defining Trees","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.narytree\nJuDGE.tree_from_file\nJuDGE.tree_from_leaves\nJuDGE.print_tree(::AbstractTree, ::Dict{AbstractTree,T} where T <: Any)","category":"page"},{"location":"api/#JuDGE.narytree","page":"API Reference","title":"JuDGE.narytree","text":"narytree(depth::Int, degree::Int)\n\nGiven the depth and degree, this function returns an N-ary tree. Note that a depth of 0 return a single Leaf node (which is also the root node of the tree).\n\nRequired Arguments\n\ndepth is the maximum number of arcs from the root node any Leaf node\n\ndegree is the number of children of all nodes, other than the Leaf nodes\n\nExample\n\ntree = narytree(2,2)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.tree_from_file","page":"API Reference","title":"JuDGE.tree_from_file","text":"tree_from_file(filename::String)\n\nConstruct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node \"A\" to node \"B\". The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the data. Each column itself converted into a dictionary, indexed by the node.\n\nRequired Arguments\n\nstring is the full path of the file containing the tree\n\nExample\n\ntree, data = tree_from_file(joinpath(@__DIR__,\"tree.csv\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.tree_from_leaves","page":"API Reference","title":"JuDGE.tree_from_leaves","text":"tree_from_leaves(leafnodes::Vector{Vector{Int}}, probs::Vector{Float64})\n\nConstruct tree from Array of leaf nodes, and (optionally) the corresponding probabilities\n\nRequired Arguments\n\nleafnodes is an array of arrays defining the set of leaf nodes\n\nOptional Arguments\n\nprobs is an array of probabilities for the leaf nodes\n\nExample\n\n(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])\ntree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.print_tree-Tuple{AbstractTree, Dict{AbstractTree, T} where T}","page":"API Reference","title":"JuDGE.print_tree","text":"print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Any})\n\nGiven some_tree, this function prints a simple representation of the tree to the REPL.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise\n\nOptional Arguments\n\ndata is a dictionary indexed by each node in some_tree\n\n\n\n\n\n","category":"method"},{"location":"api/#Nodes-of-Trees","page":"API Reference","title":"Nodes of Trees","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Base.collect\nJuDGE.get_leafnodes\nJuDGE.get_node","category":"page"},{"location":"api/#Base.collect","page":"API Reference","title":"Base.collect","text":"collect(tree::Tree;order::Symbol=:depth,truncate::Int=-1)\n\nGiven tree, this function returns an array of corresponding nodes. By default this will be in a depth-first order.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect the nodes\n\nOptional Arguments\n\norder can be set to :depth or :breadth to specify the order that the nodes are listed in the array.\n\ntruncate limits the nodes returned to a maximum depth of truncate.\n\nExamples\n\nnodes = collect(tree) #gets an array of nodes from tree in depth-first order\nnodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_leafnodes","page":"API Reference","title":"JuDGE.get_leafnodes","text":"get_leafnodes(tree::AbstractTree; truncate::Int = -1)\n\nGiven tree, this function returns an array of corresponding Leaf nodes.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect leaf nodes\n\nExample\n\nleafnodes = JuDGE.get_leafnodes(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_node","page":"API Reference","title":"JuDGE.get_node","text":"get_node(tree::AbstractTree, indices::Vector{Int})\n\nGiven a tree, and an array of indices, this function returns the corresponding node in the tree.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nindicies is an array of integer indices identifying a node within tree.\n\nExamples\n\nnode = get_node(tree,[1]) #get the root node\nnode = get_node(tree,[1,1]) #get the first child of the root node\nnode = get_node(tree,[1,2]) #get the second child of the root node\n\n\n\n\n\n","category":"function"},{"location":"api/#Tree-Probabilities","page":"API Reference","title":"Tree Probabilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.convert_probabilities\nJuDGE.ConditionallyUniformProbabilities\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"api/#JuDGE.convert_probabilities","page":"API Reference","title":"JuDGE.convert_probabilities","text":"convert_probabilities(tree::AbstractTree, probabilities::Dict{NodeID,Float64})\n\nGiven a dictionary of conditional probabilities for each node in tree, this function returns a dictionary that maps the NodeID of each node of tree to the corresponding unconditional probability.\n\nRequired Arguments\n\ntree is the tree that the probabilities pertain to\n\nprobabilities is a dictionary of condition probabilities for each node in tree\n\nExample\n\nprobs = JuDGE.convert_probabilities(tree,probabilities)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.ConditionallyUniformProbabilities","page":"API Reference","title":"JuDGE.ConditionallyUniformProbabilities","text":"ConditionallyUniformProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = ConditionallyUniformProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.UniformLeafProbabilities","page":"API Reference","title":"JuDGE.UniformLeafProbabilities","text":"UniformLeafProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = UniformLeafProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-Tree-functions","page":"API Reference","title":"Other Tree functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.depth\nJuDGE.history\nJuDGE.visualize_tree\nJuDGE.get_groups","category":"page"},{"location":"api/#JuDGE.depth","page":"API Reference","title":"JuDGE.depth","text":"depth(tree::AbstractTree)\n\nGiven tree, this function returns the depth. The root node has a depth of 0.\n\nRequired Arguments\n\ntree is the node we wish to find the depth for.\n\nExample\n\ndepth = JuDGE.depth(tree) #returns the depth of a node in a tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.history","page":"API Reference","title":"JuDGE.history","text":"history(tree::AbstractTree)\n\nGiven tree, this function returns the history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the node that we wish to find the history for.\n\nExample\n\nhistory = JuDGE.history(tree) #get a vector of nodes that precede tree\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.visualize_tree","page":"API Reference","title":"JuDGE.visualize_tree","text":"visualize_tree(some_tree::AbstractTree,\n    data::Dict{AbstractTree,Dict{Symbol,Any}};\n    scale_edges = nothing,\n    scale_nodes::Float64 = 0.0,\n    max_size::Float64 = 50.0,\n    custom::Union{Nothing,Dict{Symbol,Tuple{String,String,String}}} = nothing,\n    truncate::Int = -1)\n\nGiven some_tree, this function generates a html/js visualization of the tree.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise.\n\ndata is a dictionary of the data we wish to display, each element is a dictionary for a node of the tree, indexed by the Symbols.\n\nOptional Arguments\n\nscale_edges this is the scale factor for edges as the network gets deeper.\n\nscale_nodes this is the scale factor for nodes as the network gets deeper.\n\nmax_size this is the size of the root node.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.get_groups","page":"API Reference","title":"JuDGE.get_groups","text":"get_groups(tree::AbstractTree; combine=0)\n\nGiven a tree, this function will split it up into an array of subtrees. These can be provided as blocks for the JuDGE.solve() function to perform partial pricing.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nOptional Arguments\n\ncombine this parameter determines the size of the subtrees (higher creates larger subtrees). If set to 0, the subtrees will be the sets of paths to the leaf nodes.\n\nExamples\n\nblocks = get_groups(tree)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE-Functions","page":"API Reference","title":"JuDGE Functions","text":"","category":"section"},{"location":"api/#JuDGE-Solving-Functions","page":"API Reference","title":"JuDGE Solving Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.JuDGEModel\nJuDGE.solve(::JuDGEModel)\nJuDGE.branch_and_price\nJuDGE.Termination\nJuDGE.variable_branch\nJuDGE.resolve_subproblems\nJuDGE.set_policy!","category":"page"},{"location":"api/#JuDGE.JuDGEModel","page":"API Reference","title":"JuDGE.JuDGEModel","text":"JuDGEModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor=1.0,\n           risk=RiskNeutral(),\n           sideconstraints=nothing,\n           check=true,\n           perfect_foresight=false)\n\nDefine a JuDGE model.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nrisk can be either a Risk object, or a vector of such objects.\n\nsideconstraints is a function which specifies side constraints in the master problem, see Tutorial 9: Side-constraints for further details\n\ncheck is a boolean, which can be set to false to disable the validation of the JuDGE model.\n\nperfect_foresight is a boolean; this is an experimental feature, which creates an array of JuDGE models, one for each leaf node. This will enable users to easily compute the EVPI for the stochastic program. Also can be used for regret-based risk implementations. See the example EVPIandVSS.jl.\n\nExamples\n\njudge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, risk=Risk(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.solve-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(judge::JuDGEModel;\n      termination::Termination=Termination(),\n      max_no_int::Int=typemax(Int),\n      blocks::Union{Nothing,Vector{Vector{AbstractTree}}}=nothing,\n      warm_starts::Bool=false,\n      optimizer_attributes::Union{Nothing,Function}=nothing,\n      mp_callback::Union{Nothing,Function}=nothing,\n      prune::Float64=Inf,\n      heuristic::Union{Nothing,Function}=nothing,\n      verbose::Int=2)\n\nSolve a JuDGEModel judge without branch-and-price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\ntermination is a Termination object containing all the stopping conditions.\n\nmax_no_int is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the relgap / absgap stopping conditions. To override this, set max_no_int to the negative of the number desired value.\n\nblocks specifies the groups of nodes to solve in each iteration (these groups can be generated using JuDGE.get_groups(), or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See advanced.jl for more details.\n\nwarm_starts boolean specifing whether to use warm starts for subproblems and binary solves of master problem.\n\noptimizer_attributes can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the advanced.jl example.\n\nmp_callback is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.\n\nprune is used to stop the algorithm before convergence, if a known upper bound for the problem is specified.\n\nheuristic is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.\n\nverbose if 0, all output from solve will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.\n\nExamples\n\nJuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6))\nJuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6), max_no_int=-5)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.branch_and_price","page":"API Reference","title":"JuDGE.branch_and_price","text":"branch_and_price(models::Union{JuDGEModel,Vector{JuDGEModel}};\n\tbranch_method::Function=JuDGE.variable_branch,search::Symbol=:lowestLB,\n\ttermination::Termination=Termination(),\n\tmax_no_int::Int=typemax(Int),\n\tblocks::Union{Nothing,Vector{Vector{AbstractTree}}}=nothing,\n\twarm_starts::Bool=false,\n\toptimizer_attributes::Union{Nothing,Function}=nothing,\n\tmp_callback::Union{Nothing,Function}=nothing,\n\tbp_callback::Union{Nothing,Function}=nothing,\n\theuristic::Union{Nothing,Function}=nothing,\n\tverbose::Int=2)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nbranch_method is a function specifies the way that constraints are added to create new nodes in the branchandprice tree.\n\nsearch specifies the order in which nodes are solved in the (branch-and-price) tree. Options are: :lowestLB, :depth_first_dive, :depth_first_resurface, :breadth_first.\n\ntermination is a Termination object containing all the stopping conditions.\n\nmax_no_int is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the relgap / absgap stopping conditions. To override this, set max_no_int to the negative of the number desired value.\n\nblocks specifies the groups of nodes to solve in each iteration (these groups can be generated using JuDGE.get_groups(), or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See advanced.jl for more details.\n\nwarm_starts boolean specifing whether to use warm starts for subproblems and binary solves of master problem.\n\noptimizer_attributes can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the advanced.jl example.\n\nmp_callback is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.\n\nbp_callback is a user-defined function that allows you to modify the Termination conditions for JuDGE.solve and the search policy during the branch-and-price process.\n\nheuristic is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.\n\nverbose if 0, most output from JuDGE.solve will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.\n\nExamples\n\nJuDGE.branch_and_price(jmodel, termination=Termination(abstol=10^-6))\nJuDGE.branch_and_price(jmodel, search=:depth_first_dive, verbose=0)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.Termination","page":"API Reference","title":"JuDGE.Termination","text":"Termination(;abstol::Float64=10^-9,             reltol::Float64=10^-9,             rlxabstol::Float64=10^-9,             rlxreltol::Float64=10^-9,             timelimit::Float64=Inf,             maxiter::Int=typemax(Int),             inttol::Float64=10^-8,             allowfrac::Symbol=:binarysolve)\n\nDefine the stopping conditions for JuDGE.solve() / JuDGE.branch_and_price().\n\nOptional Arguments\n\nabstol is the absolute tolerance for the best integer-feasible objective value and the lower bound.\n\nreltol is the relative tolerance for the best integer-feasible objective value and the lower bound.\n\nrlx_abstol is the absolute tolerance for the relaxed master objective value and the lower bound.\n\nrlx_reltol is the relative tolerance for the relaxed master objective value and the lower bound.\n\ntime_limit is the maximum duration in seconds.\n\nmax_iter is the maximum number of iterations.\n\ninttol is the maximum deviation from 0 or 1 for any binary/integer variable for integer feasible solutions.\n\nallow_frac indicates whether a fractional solution will be returned; possible values are:     :binary_solve a binary solve of master will be performed (if needed) prior to the solution being returned;     :binary_solve_return_relaxation a binary solve of master will be performed (if needed), updating the upper bound,     but the master problem relation will be returned;     :first_fractional will return the first fractional master solution found;     :no_binary_solve will simply return the solution to the relaxed master problem when terminated.\n\nExamples\n\nTermination(rlx_abstol=10^-6)    Termination(abstol=10^-3,inttol=10^-6)\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.variable_branch","page":"API Reference","title":"JuDGE.variable_branch","text":"variable_branch(jmodel::JuDGEModel, inttol::Float64)\n\nThis is an in-built function that is called during branch-and-price to perform a branch. Users can define their own functions that follow this format to create new branching strategies.\n\nRequired Arguments\n\njmodel is the JuDGE model\n\ninttol is the maximum permitted deviation from binary/integer for a value to still be considered binary/integer feasible.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.resolve_subproblems","page":"API Reference","title":"JuDGE.resolve_subproblems","text":"resolve_subproblems(judge::JuDGEModel)\n\nOnce a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.\n\nRequired Arguments\n\njmodel is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nforce_match if true will force all expansion and shutdown variables in the subproblem to exactly match the master problem.\n\nExamples\n\nresolve_subproblems(judge)\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.set_policy!","page":"API Reference","title":"JuDGE.set_policy!","text":"set_policy!(     jmodel::JuDGEModel,     jmodel2::JuDGEModel,     mapping::Union{Symbol,Dict{AbstractTree,AbstractTree}})\n\nFixes the policy of a JuDGEModel object based on another JuDGEModel object.\n\nRequired Arguments\n\njmodel is the JuDGE model for which we wish to set the policy. jmodel2 is the JuDGE model from which we wish to copy the policy. mapping is can either be set to the symbol :by_depth or :by_nodeID or be an explicit dictionary mapping the nodes in jmodel.tree the nodes in jmodel2.tree. For any node in jmodel.tree that is not mapped, no policy is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE-Macros-for-Subproblems","page":"API Reference","title":"JuDGE Macros for Subproblems","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.@expansion\nJuDGE.@shutdown\nJuDGE.@enforced\nJuDGE.@state\nJuDGE.@capitalcosts\nJuDGE.@ongoingcosts","category":"page"},{"location":"api/#JuDGE.@expansion","page":"API Reference","title":"JuDGE.@expansion","text":"expansion(model, variable, args...)\n\nDefines an expansion variable variable within a subproblem model. Note that all subproblems must have the same set of expansion variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available.\n\nduration is the number of consecutive nodes in the scenario over which an expansion is available.\n\nlb is the lower bound for this variable in the master problem (typically omitted).\n\nub is the upper bound for this variable in the master problem (typically omitted).\n\nExamples\n\n@expansion(model, expand[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan\n@expansion(model, expand[1:5,1:2]>=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration\n@expansion(model, 0<=expand<=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@shutdown","page":"API Reference","title":"JuDGE.@shutdown","text":"shutdown(model, variable, args...)\n\nDefines an shutdown variable variable within a subproblem model. Note that all subproblems must have the same set of shutdown variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the shutdown variable to\n\nvariable is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nlag is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable.\n\nduration is the number of consecutive nodes in the scenario over which the shutdown will last.\n\nlb is the lower bound for this variable in the master problem (typically omitted).\n\nub is the upper bound for this variable in the master problem (typically omitted).\n\nExamples\n\n@shutdown(model, shut[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan\n@shutdown(model, shut[1:5,1:2]>=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration\n@shutdown(model, 0<=shut<=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@enforced","page":"API Reference","title":"JuDGE.@enforced","text":"enforced(model, variable, args...)\n\nDefines an enforced variable variable within a subproblem model. Note that all subproblems must have the same set of enforced variables. These variables can be used as either expansion or shutdown variables, but since the constraint in the master problem is an equality, convergence is more difficult since there is less flexibility when solving the master problem.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available.\n\nduration is the number of consecutive nodes in the scenario over which an expansion is available.\n\nlb is the lower bound for this variable in the master problem (typically omitted).\n\nub is the upper bound for this variable in the master problem (typically omitted).\n\npenalty is a placeholder for a future feature, which may allow the violation of master/subproblem equality constraint, at a cost.\n\nExamples\n\n@expansion(model, forced[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan\n@expansion(model, forced[1:5,1:2]>=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration\n@expansion(model, 0<=forced<=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@state","page":"API Reference","title":"JuDGE.@state","text":"state(model, variable, args...)\n\nDefines a state variable variable within a subproblem model. Note that all subproblems must have the same set of state variables. These variables can be used to model inventory that is carried forward between the subproblems.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created in the subproblem, this will be continuous by default; follows JuMP syntax if defining a set of variables. The subproblem variable corresponds to the change in the state.\n\nOptional Arguments\n\nThis macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the @variable macro.\n\nstate_name is the name for the state variable in the master problem. If omitted, the name of the master problem variable will match the subproblem variable (but this may cause confusion, since only the master problem variable is the state). See the inventory.jl example to see how this should be implemented.\n\ninitial is the initial value for the master problem's state variable at the root node.\n\nlb is the lower bound for the variable in the master problem (typically omitted).\n\nub is the upper bound for the variable in the master problem (typically omitted).\n\nExamples\n\n@state(sp, -50<=Δstock<=50, state_name=stock, lb=0, ub=200, initial=0) #defines a state variable called stock in the master\n                                                                       #(starting at 0, and able to take values 0 to 200),\n                                                                       #and Δstock in the subproblem (able to change the stock level by ±50).\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@capitalcosts","page":"API Reference","title":"JuDGE.@capitalcosts","text":"capitalcosts(model, expr)\n\nDefines a linear expression specifying the capital cost of expansions and shutdowns at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the total cost of choosing expansion and shutdown variables at the current node\n\nExample\n\n@capitalcosts(model, sum(expand[i]*cost[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE.@ongoingcosts","page":"API Reference","title":"JuDGE.@ongoingcosts","text":"ongoingcosts(model, expr)\n\nDefines a linear expression specifying the ongoing costs of expansions and shutdowns available at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the ongoing cost of expansions and shutdowns available at the current node\n\nExample\n\n@ongoingcosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"api/#JuDGE-Solutions-/-Output","page":"API Reference","title":"JuDGE Solutions / Output","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.solution_to_dictionary(::JuDGEModel)\nJuDGE.get_active_columns(::JuDGEModel)\nJuDGE.write_solution_to_file(::JuDGEModel,::String)\nJuDGE.print_expansions(::JuDGEModel)","category":"page"},{"location":"api/#JuDGE.solution_to_dictionary-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.solution_to_dictionary","text":"solution_to_dictionary(jmodel::JuDGEModel; prefix::String = \"\")\n\nCreate a nested dictionary with the solution values for each node copied across to a standardised structure.\n\nRequired Arguments\n\njmodel is a solved JuDGEModel\n\nOptional Arguments\n\nprefix is a string that will be prepended to each of the variable names (e.g. if comparing to versions of the same model)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.get_active_columns-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.get_active_columns","text":"get_active_columns(jmodel::JuDGEModel; inttol = 10^-7)\n\nReturns a list of tuples of non-zero columns along with their corresponding value.\n\nRequired Arguments\n\njmodel is a solved JuDGEModel\n\nOptional Arguments\n\ninttol is the minimum value for a variable to be deemed non-zero\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.write_solution_to_file-Tuple{JuDGEModel, String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(model::Union{JuDGEModel,DetEqModel},filename::String)\n\nGiven a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\nmodel can be either the JuDGEModel or the DetEqModel whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.print_expansions-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(jmodel::JuDGEModel;\n                 onlynonzero::Bool=true,\n                 inttol=10^-9,\n                 format=nothing)\n\nGiven a solved JuDGE model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See Tutorial 2: Formatting output for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Deterministic-Equivalent","page":"API Reference","title":"Deterministic Equivalent","text":"","category":"section"},{"location":"api/#Define-and-Solve-DetEq-Model","page":"API Reference","title":"Define and Solve DetEq Model","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.DetEqModel\nJuDGE.solve(::DetEqModel)\nJuDGE.set_starting_solution!","category":"page"},{"location":"api/#JuDGE.DetEqModel","page":"API Reference","title":"JuDGE.DetEqModel","text":"DetEqModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver\n           discount_factor=1.0,\n           risk=RiskNeutral,\n           sideconstraints=nothing,\n           check=true)\n\nDefine a deterministic equivalent model for the stochastic capacity expansion problem.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for this problem (with appropriate settings)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nrisk is a tuple with the two CVaR parameters: (λ, α)\n\nsideconstraints is a function which specifies side constraints in the master problem, see Tutorial 9: Side-constraints for further details.\n\ncheck is a boolean, which can be set to false to disable the validation of the JuDGE model.\n\nExamples\n\ndeteq = DetEqModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = DetEqModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, risk=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"api/#JuDGE.solve-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(deteq::DetEqModel)\n\nSolve a determinisitc equivalent model.\n\nRequired Arguments\n\ndeteq is the determinisitc equivalent model that we wish to solve.\n\nExample\n\nJuDGE.solve(deteq)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.set_starting_solution!","page":"API Reference","title":"JuDGE.set_starting_solution!","text":"set_starting_solution!(deteq::DetEqModel, jmodel::JuDGEModel)\n\nUse the best solution from a JuDGEModel to warm start the deterministic equivalent.\n\nRequired Arguments\n\ndeteq is an unsolved DetEqModel jmodel is a solved JuDGEModel\n\n\n\n\n\n","category":"function"},{"location":"api/#DetEq-Solutions-/-Output","page":"API Reference","title":"DetEq Solutions / Output","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.solution_to_dictionary(::DetEqModel)\nJuDGE.write_solution_to_file(::DetEqModel,::String)\nJuDGE.print_expansions(::DetEqModel)","category":"page"},{"location":"api/#JuDGE.solution_to_dictionary-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.solution_to_dictionary","text":"solution_to_dictionary(deteq::DetEqModel; prefix::String = \"\")\n\nCreate a nested dictionary with the solution values for each node copied across to a standardised structure.\n\nRequired Arguments\n\ndeteq is a solved DetEqModel\n\nOptional Arguments\n\nprefix is a string that will be prepended to each of the variable names (e.g. if comparing to versions of the same model)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.write_solution_to_file-Tuple{DetEqModel, String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(model::Union{JuDGEModel,DetEqModel},filename::String)\n\nGiven a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\nmodel can be either the JuDGEModel or the DetEqModel whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.print_expansions-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(deteq::DetEqModel;\n                 onlynonzero::Bool=true,\n                 inttol=10^-9,\n                 format=nothing)\n\nGiven a solved deterministic equivalent model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See Tutorial 2: Formatting output for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Risk","page":"API Reference","title":"Risk","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.RiskNeutral()\nJuDGE.Risk(::Float64,::Float64;::Union{Dict{Leaf,Float64},Nothing},::Union{Float64,Nothing},::Float64)\nJuDGE.Risk(::Float64;::Union{Dict{Leaf,Float64},Nothing},::Union{Float64,Nothing},::Float64)","category":"page"},{"location":"api/#JuDGE.RiskNeutral-Tuple{}","page":"API Reference","title":"JuDGE.RiskNeutral","text":"RiskNeutral()\n\nCreate a risk-neutral risk measure.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.Risk-Tuple{Float64, Float64}","page":"API Reference","title":"JuDGE.Risk","text":"Risk(λ::Real,\n     α::Real;\n     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,\n     bound::Union{Real,Nothing}=nothing,\n     penalty::Union{Real,Nothing} = nothing)\n\nDefine the CVaR risk measure to be applied to the accumulated profits at the leaf nodes.\n\nRequired Arguments\n\nλ is weighting applied for the risk measure (max sum of weightings should be 1.0), if sum of weightings is less than 1.0, expected value will make up the rest.\n\nα is the probability in the tail of the distribution\n\nOptional Arguments\n\noffset applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.\n\nbound if used, this will create a constraint on CVaR(α) with this as the upper bound.\n\npenalty if a constraint on CVaR is applied, then the marginal cost of violating the constraint is penalty; if set to nothing then no constraint violation is allowed.)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuDGE.Risk-Tuple{Float64}","page":"API Reference","title":"JuDGE.Risk","text":"Risk(α::Real;\n     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,\n     bound::Union{Real,Nothing}=nothing,\n     penalty::Union{Real,Nothing} = nothing)\n\nDefine the CVaR risk constraint to be applied to the accumulated profits at the leaf nodes.\n\nRequired Arguments\n\nλ is weighting applied for the risk measure (max sum of weightings should be 1.0), if sum of weightings is less than 1.0, expected value will make up the rest.\n\nα is the probability in the tail of the distribution\n\nOptional Arguments\n\noffset applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.\n\nbound if used, this will create a constraint on CVaR(α) with this as the upper bound.\n\npenalty if a constraint on CVaR is applied, then the marginal cost of violating the constraint is penalty; if set to nothing then no constraint violation is allowed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Other-functions","page":"API Reference","title":"Other functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"JuDGE.remove_from_dictionary!\nJuDGE.add_to_dictionary!","category":"page"},{"location":"api/#JuDGE.remove_from_dictionary!","page":"API Reference","title":"JuDGE.remove_from_dictionary!","text":"remove_from_dictionary!(\n    original::Dict{AbstractTree,Dict{Symbol,Any}},\n    sym::Union{Symbol,Vector{Symbol}})\n\nGiven a dictionary produced by the solution_to_dictionary() function, and a Symbol or Symbol[], this function removes that/those Symbol(s) from the dictionary.\n\nRequired Arguments\n\noriginal is a dictionary produced by solution_to_dictionary() sym is a Symbol or Symbol vector of keys to remove from each node within the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"api/#JuDGE.add_to_dictionary!","page":"API Reference","title":"JuDGE.add_to_dictionary!","text":"add_to_dictionary!(\n    original::Dict{AbstractTree,Dict{Symbol,Any}},\n    add::T where {T<:Dict},\n    sym::Union{Symbol,Vector{Symbol}})\n\nGiven a dictionary produced by the solution_to_dictionary() function, and a Symbol or Symbol[], this function adds that/those Symbol(s) to the dictionary.\n\nRequired Arguments\n\noriginal is a dictionary produced by solution_to_dictionary() add is the dictionary (with the keys being AbstractTree objects) that you wish to add to the original dictionary sym is a Symbol or Symbol vector of keys to add to each node within the dictionary\n\n\n\n\n\n","category":"function"},{"location":"","page":"JuDGE","title":"JuDGE","text":"CurrentModule = JuDGE\nDocTestSetup = quote\n    using JuDGE\nend","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"(Image: JuDGE)","category":"page"},{"location":"#JuDGE.jl","page":"JuDGE","title":"JuDGE.jl","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE stands for: Julia Decomposition for Generalized Expansion. Functionally, it is a solver which leverages the syntax of the JuMP modelling language to solve a particular class of capacity expansion problems.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"For more details see our working paper: JuDGE.jl: a Julia package for optimizing capacity expansion.","category":"page"},{"location":"#Problem-Class-/-Decomposition","page":"JuDGE","title":"Problem Class / Decomposition","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE solves multi-stage stochastic integer programming problems using Dantzig-Wolfe decomposition. The user must specify a tree that represents the uncertainty of the problem, and at each node define a subproblem that can be a linear or integer program. Further, the expansion variables which link the subproblems must be declared.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE automatically generates a master problem and performs column generation to converge to an optimal solution.","category":"page"},{"location":"#Requirements","page":"JuDGE","title":"Requirements","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE requires Julia-1.6+, JuMP and appropriate optimiser(s). For academics, Gurobi / CPLEX provide free academic licenses, otherwise, you can use CBC/Clp or GLPK.","category":"page"},{"location":"#Installation","page":"JuDGE","title":"Installation","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is installed by the Pkg utility provided by Julia. In the Julia REPL, simply make the following function call.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"] add \"https://github.com/EPOC-NZ/JuDGE.jl\"","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Then, in your Julia script, use","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"using JuDGE","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"to import the functions from the JuDGE module into the current namespace.","category":"page"},{"location":"#Stochastic-Knapsack-Example","page":"JuDGE","title":"Stochastic Knapsack Example","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is distributed with an example of a multi-stage stochastic integer programming problem. This is a stochastic knapsack problem with investment. The file knapsack.jl contains the implementation of this problem within the JuDGE framework. There are also a number of variants of this model demonstrating other features of JuDGE.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"See the Tutorials for details about this.","category":"page"},{"location":"#Limitations","page":"JuDGE","title":"Limitations","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"The package is currently under development, and while it has been tested on a","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"number of example problems, there may be some issues that have yet to be addressed.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Support for decisions to reduce capacity is not fully tested.","category":"page"},{"location":"#Bugs","page":"JuDGE","title":"Bugs","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Please raise an issue if you experience an error while using JuDGE.","category":"page"}]
}
