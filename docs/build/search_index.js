var documenterSearchIndex = {"docs":
[{"location":"index.html","page":"Main","title":"Main","text":"CurrentModule = JuDGE\r\nDocTestSetup = quote\r\n    using JuDGE\r\nend","category":"page"},{"location":"index.html#JuDGE-functions","page":"Main","title":"JuDGE functions","text":"","category":"section"},{"location":"index.html","page":"Main","title":"Main","text":"JuDGE.JuDGEModel\r\nJuDGE.solve\r\nJuDGE.resolve_subproblems","category":"page"},{"location":"index.html#JuDGE.JuDGEModel","page":"Main","title":"JuDGE.JuDGEModel","text":"JuDGEModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor::Float64,\n           CVaR::Tuple{Float64,Float64},\n           sideconstraints)\n\nDefine a JuDGE model.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nCVaR is a tuple with the two CVaR parameters: (λ, β)\n\nsideconstraints is a function which specifies side constraints in the master problem, see example * for further details.\n\nExamples\n\njudge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, CVaR=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"index.html#JuDGE.solve","page":"Main","title":"JuDGE.solve","text":"solve(judge::JuDGEModel;\n      abstol = 10^-14,\n      reltol = 10^-14,\n      rlx_abstol = 10^-14,\n      rlx_reltol = 10^-14,\n      duration = Inf,\n      iter = 2^63 - 1,\n      inttol = 10^-9,\n      allow_frac = 0,\n      prune = Inf)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nabstol is the absolute tolerance for the best integer-feasible objective value and the lower bound\n\nreltol is the relative tolerance for the best integer-feasible objective value and the lower bound\n\nrlx_abstol is the absolute tolerance for the relaxed master objective value and the lower bound\n\nrlx_reltol is Set the relative tolerance for the relaxed master objective value and the lower bound\n\nduration is the maximum duration\n\niter is the maximum number of iterations\n\ninttol is the maximum deviation from 0 or 1 for integer feasible solutions\n\nUsed by the branch and price algorithm\n\nallow_frac indicates wheither a fractional solution will be returned\n\nprune is used to stop the algorithm before convergence, if a known upper bound for the problem is specified\n\nExamples\n\nJuDGEModel(jmodel, rlx_abstol=10^-6)\nJuDGEModel(jmodel, abstol=10^-6)\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.resolve_subproblems","page":"Main","title":"JuDGE.resolve_subproblems","text":"resolve_subproblems(judge::JuDGEModel)\n\nOnce a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.\n\nRequired Arguments\n\njmodel is the JuDGE model that we wish to solve.\n\nExamples\n\nresolve_subproblems(judge)\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE-macros-for-subproblems","page":"Main","title":"JuDGE macros for subproblems","text":"","category":"section"},{"location":"index.html","page":"Main","title":"Main","text":"JuDGE.@expansion\r\nJuDGE.@shutdown\r\nJuDGE.@expansioncosts\r\nJuDGE.@maintenancecosts\r\nJuDGE.@sp_objective","category":"page"},{"location":"index.html#JuDGE.@expansion","page":"Main","title":"JuDGE.@expansion","text":"expansion(model, variable, lag, span)\n\nDefines an expansion variable variable within a subproblem model. Note that all subproblems must have the same set of expansion variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available\n\nspan is the number of consecutive nodes in the scenario over which an expansion is available\n\nExamples\n\n@expansion(model, expand[1:5]) #defines an array of 5 variables with no lag, and unlimited lifespan\n@expansion(model, expand[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited lifespan\n@expansion(model, expand, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"index.html#JuDGE.@shutdown","page":"Main","title":"JuDGE.@shutdown","text":"shutdown(model, variable, lag, span)\n\nDefines an shutdown variable variable within a subproblem model. Note that all subproblems must have the same set of shutdown variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the shutdown variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable\n\nspan is the number of consecutive nodes in the scenario over which the shutdown will last\n\nExamples\n\n@shutdown(model, shut[1:5]) #defines an array of 5 variables with no lag, and unlimited duration\n@shutdown(model, shut[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited duration\n@shutdown(model, shut, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"index.html#JuDGE.@expansioncosts","page":"Main","title":"JuDGE.@expansioncosts","text":"expansioncosts(model, expr)\n\nDefines a linear expression specifying the cost of expansions and shutdowns at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the total cost of choosing expansion and shutdown variables at the current node\n\nExample\n\n@expansioncosts(model, sum(expand[i]*cost[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"index.html#JuDGE.@maintenancecosts","page":"Main","title":"JuDGE.@maintenancecosts","text":"maintenancecosts(model, expr)\n\nDefines a linear expression specifying the ongoing cost of expansions and shutdowns available at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the ongoing cost of expansions and shutdowns available at the current node\n\nExample\n\n@maintenancecosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"index.html#JuDGE.@sp_objective","page":"Main","title":"JuDGE.@sp_objective","text":"sp_objective(model, expr)\n\nDefines a linear expression specifying the cost of operating the system for the current node, excluding expansion or ongoing costs.\n\nIf it's possible to avoid costs by not using some previously expanded capacity, this can be included here with by directly including the expansion variable in the expression.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the subproblem costs.\n\nExample\n\n@sp_objective(model, sum(y[i]*c[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Defining-Trees","page":"Main","title":"Defining Trees","text":"","category":"section"},{"location":"index.html","page":"Main","title":"Main","text":"JuDGE.narytree\r\nJuDGE.tree_from_file\r\nJuDGE.tree_from_leaves\r\nJuDGE.print_tree","category":"page"},{"location":"index.html#JuDGE.narytree","page":"Main","title":"JuDGE.narytree","text":"narytree(depth::Int64, degree::Int64)\n\nGiven the depth and degree, this function returns an N-ary tree. Note that a depth of 0 return a single Leaf node (which is also the root node of the tree).\n\nRequired Arguments\n\ndepth is the maximum number of arcs from the root node any Leaf node degree is the number of children of all nodes, other than the Leaf nodes\n\nExample\n\ntree = narytree(2,2)\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.tree_from_file","page":"Main","title":"JuDGE.tree_from_file","text":"tree_from_file(filename::String)\n\nConstruct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node \"A\" to node \"B\". The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the data. Each column itself converted into a dictionary, indexed by the node.\n\nRequired Arguments\n\nstring is the full path of the file containing the tree\n\nExample\n\ntree, data = tree_from_file(joinpath(@__DIR__,\"tree.csv\"))\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.tree_from_leaves","page":"Main","title":"JuDGE.tree_from_leaves","text":"tree_from_leaves(leafnodes::Array{Array{Int64,1},1}, probs::Array{Float64,1})\n\nConstruct tree from Array of leaf nodes, and (optionally) the corresponding probabilities\n\nRequired Arguments\n\nleafnodes is an array of arrays defining the set of leaf nodes\n\nOptional Arguments\n\nprobs is an array of probabilities for the leaf nodes\n\nExample\n\n(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])\ntree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.print_tree","page":"Main","title":"JuDGE.print_tree","text":"print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Float64})\n\nGiven some_tree, this function prints a simple representation of the tree to the REPL.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise\n\nOptional Arguments\n\ndata is a dictionary indexed by the nodes of some_tree\n\n\n\n\n\n","category":"function"},{"location":"index.html#Nodes-of-Trees","page":"Main","title":"Nodes of Trees","text":"","category":"section"},{"location":"index.html","page":"Main","title":"Main","text":"Base.collect\r\nJuDGE.get_leafnodes\r\nJuDGE.get_node","category":"page"},{"location":"index.html#Base.collect","page":"Main","title":"Base.collect","text":"collect(tree::Tree;order=:depth)\n\nGiven tree, this function returns an array of corresponding nodes. By default this will be in a depth-first order.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect the nodes\n\nOptional Arguments\n\norder can be set to :depth or :breadth to specify the order that the nodes are listed in the array.\n\nExamples\n\nnodes = collect(tree) #gets an array of nodes from tree in depth-first order\nnodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.get_leafnodes","page":"Main","title":"JuDGE.get_leafnodes","text":"get_leafnodes(tree::AbstractTree)\n\nGiven tree, this function returns an array of corresponding Leaf nodes.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect leaf nodes\n\nExample\n\nleafnodes = JuDGE.get_leafnodes(tree) #define a function that returns the parent of each node in the tree\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.get_node","page":"Main","title":"JuDGE.get_node","text":"get_node(tree::AbstractTree, indices::Array{Int64,1})\n\nGiven a tree, and an array of indices, this function returns the corresponding node in the tree.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node indicies is an array of integer indices identifying a node within tree.\n\nExamples\n\nnode = get_node(tree,[1]) #get the root node\nnode = get_node(tree,[1,1]) #get the first child of the root node\nnode = get_node(tree,[1,2]) #get the second child of the root node\n\n\n\n\n\n","category":"function"},{"location":"index.html#Tree-Probabilities","page":"Main","title":"Tree Probabilities","text":"","category":"section"},{"location":"index.html","page":"Main","title":"Main","text":"JuDGE.convert_probabilities\r\nJuDGE.ConditionallyUniformProbabilities\r\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"index.html#JuDGE.convert_probabilities","page":"Main","title":"JuDGE.convert_probabilities","text":"convert_probabilities(tree::AbstractTree, probabilities::Dict{AbstractTree,Float64})\n\nGiven a dictionary of conditional probabilities for each node in tree, this function returns a dictionary that maps node of tree to the corresponding unconditional probability.\n\nRequired Arguments\n\ntree is the tree that the probabilities pertain to probabilities is a dictionary of condition probabilities for each node in tree\n\nExample\n\nprobs = JuDGE.convert_probabilities(tree,probabilities)\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.ConditionallyUniformProbabilities","page":"Main","title":"JuDGE.ConditionallyUniformProbabilities","text":"ConditionallyUniformProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = ConditionallyUniformProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.UniformLeafProbabilities","page":"Main","title":"JuDGE.UniformLeafProbabilities","text":"UniformLeafProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = UniformLeafProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"index.html#Other-Tree-functions","page":"Main","title":"Other Tree functions","text":"","category":"section"},{"location":"index.html","page":"Main","title":"Main","text":"JuDGE.depth\r\nJuDGE.history\r\nJuDGE.parent_builder","category":"page"},{"location":"index.html#JuDGE.depth","page":"Main","title":"JuDGE.depth","text":"depth(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a subtree of tree and returns that subtree's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\ndepth_fn = JuDGE.history(tree) #define a function that returns the depth of each node in the tree\ndpth = depth_fn(node) #get the depth of node in tree\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.history","page":"Main","title":"JuDGE.history","text":"history(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\nhistory_fn = JuDGE.history(tree) #define a function that returns the history of each node in the tree\npast = history_fn(node) #get a vector of nodes that precede node in tree\n\n\n\n\n\n","category":"function"},{"location":"index.html#JuDGE.parent_builder","page":"Main","title":"JuDGE.parent_builder","text":"parent_builder(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's parent.\n\nRequired Arguments\n\ntree is the tree that the parent function will correspond to.\n\nExample\n\nparent_fn = JuDGE.parent_builder(tree) #define a function that returns the parent of each node in the tree\np = parent_fn(node) #get the parent of node\n\n\n\n\n\n","category":"function"}]
}
