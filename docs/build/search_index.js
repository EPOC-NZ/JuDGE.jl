var documenterSearchIndex = {"docs":
[{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"EditURL = \"<unknown>/F0PKY/docs/src/examples/02-knapsack-branch.jl\"","category":"page"},{"location":"examples/02-knapsack-branch.html#Knapsack-Problem-Branch-and-Price","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"","category":"section"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"This example demonstrates how the branch and price algorithm can be used to solve a JuDGE model.","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"using JuMP, JuDGE, Random","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"We will randomly generate data for this problem, but to ensure a consistent result we first set the random seed.","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Random.seed!(50)","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"We specify that there are 5 possible expansion investments, and 10 items to select from at each node.","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"numinvest = 5\nnumitems = 10","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"The tree is defined to have a depth and 4 and a degree of 3.","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"mytree = narytree(4,3)","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Find the number of nodes in the tree","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"totalnodes = JuDGE.count(mytree)","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up the investment cost data","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"investcost = zeros(totalnodes,numinvest)\nfor i = 1:totalnodes\n  investcost[i,:] = ([1,1.8,3.5,6.8,13.5])*(1-((i-1)/(totalnodes*1.2)))\nend","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Specify the investment volumes using a binary expansion, with an initial capacity of 0","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"investvol = [1,2,4,8,16]\ninitialcap = 0","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Randomly specify the item volumes and costs","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"itemvolume = zeros(totalnodes,numitems)\nfor i = 1:totalnodes\n  itemvolume[i,:] = ((rand(numitems))*2) + collect(range(4,22,length = numitems))\nend\n\nitemcost = zeros(totalnodes,numitems)\nfor i = 1:totalnodes\n  itemcost[i,:] = ((rand(numitems) .- 0.5)*2)*2# + collect(range(0.5,1,length = numitems))\nend","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Create a function that maps the node, and data name to a value","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"nodes = collect(mytree)\nfunction data(node, input)\n  input[findall(x -> x == node, nodes)[1], :]\nend","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Define the subproblems as a function of the node","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"function sub_problems(node)\n  model = Model(JuDGE_SP_Solver)\n  @expansion(model, bag[1:numinvest])\n  @expansioncosts(model, sum(data(node,investcost)[i] * bag[i] for i in  1:numinvest))\n  @variable(model, y[1:numitems], Bin)\n  @constraint(model, BagExtension ,sum( y[i]*data(node,itemvolume)[i] for i in 1:numitems) <=\n  \t\t\t\tinitialcap + sum(bag[i]*investvol[i] for i in 1:numinvest))\n  @sp_objective(model, sum(-data(node,itemcost)[i] * y[i] for i in 1:numitems))\n  model\nend","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up the JuDGE model.","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Solve the JuDGE model using the branch and price algorithm, using a constraint branch and branching on the lowest lower bound nodes first","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"best=JuDGE.branch_and_price(judy,rlx_abstol=10^-7,inttol=10^-6,\n\t\t\t\tbranch_method=JuDGE.constraint_branch,search=:lowestLB)","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Print the objective function value","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"println(\"Objective: \"*string(objective_value(best.master_problem)))","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Create a custom function that formats the output for print_expansions(...), and print the expansions using this function","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"function format_output(s::Symbol,values)\n  if s==:bag\n\t return sum(values[i]*investvol[i] for i in 1:numinvest)\n  end\n  return nothing\nend\n\nJuDGE.print_expansions(best,format=format_output)","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up and solve the deterministic equivalent problem","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"deteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)\nprintln(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"","category":"page"},{"location":"examples/02-knapsack-branch.html","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"This page was generated using Literate.jl.","category":"page"},{"location":"judge.html#JuDGE-API","page":"JuDGE API","title":"JuDGE API","text":"","category":"section"},{"location":"judge.html#JuDGE-Functions","page":"JuDGE API","title":"JuDGE Functions","text":"","category":"section"},{"location":"judge.html","page":"JuDGE API","title":"JuDGE API","text":"JuDGE.JuDGEModel\r\nJuDGE.solve\r\nJuDGE.resolve_subproblems","category":"page"},{"location":"judge.html#JuDGE.JuDGEModel","page":"JuDGE API","title":"JuDGE.JuDGEModel","text":"JuDGEModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor::Float64,\n           CVaR::Tuple{Float64,Float64},\n           sideconstraints)\n\nDefine a JuDGE model.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nCVaR is a tuple with the two CVaR parameters: (λ, β)\n\nsideconstraints is a function which specifies side constraints in the master problem, see example * for further details.\n\nExamples\n\njudge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, CVaR=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"judge.html#JuDGE.solve","page":"JuDGE API","title":"JuDGE.solve","text":"solve(judge::JuDGEModel;\n      abstol = 10^-14,\n      reltol = 10^-14,\n      rlx_abstol = 10^-14,\n      rlx_reltol = 10^-14,\n      duration = Inf,\n      iter = 2^63 - 1,\n      inttol = 10^-9,\n      allow_frac = 0,\n      prune = Inf)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nabstol is the absolute tolerance for the best integer-feasible objective value and the lower bound\n\nreltol is the relative tolerance for the best integer-feasible objective value and the lower bound\n\nrlx_abstol is the absolute tolerance for the relaxed master objective value and the lower bound\n\nrlx_reltol is Set the relative tolerance for the relaxed master objective value and the lower bound\n\nduration is the maximum duration\n\niter is the maximum number of iterations\n\ninttol is the maximum deviation from 0 or 1 for integer feasible solutions\n\nUsed by the branch and price algorithm\n\nallow_frac indicates wheither a fractional solution will be returned\n\nprune is used to stop the algorithm before convergence, if a known upper bound for the problem is specified\n\nExamples\n\nJuDGEModel(jmodel, rlx_abstol=10^-6)\nJuDGEModel(jmodel, abstol=10^-6)\n\n\n\n\n\n","category":"function"},{"location":"judge.html#JuDGE.resolve_subproblems","page":"JuDGE API","title":"JuDGE.resolve_subproblems","text":"resolve_subproblems(judge::JuDGEModel)\n\nOnce a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.\n\nRequired Arguments\n\njmodel is the JuDGE model that we wish to solve.\n\nExamples\n\nresolve_subproblems(judge)\n\n\n\n\n\n","category":"function"},{"location":"judge.html#JuDGE-macros-for-subproblems","page":"JuDGE API","title":"JuDGE macros for subproblems","text":"","category":"section"},{"location":"judge.html","page":"JuDGE API","title":"JuDGE API","text":"JuDGE.@expansion\r\nJuDGE.@shutdown\r\nJuDGE.@expansioncosts\r\nJuDGE.@maintenancecosts\r\nJuDGE.@sp_objective","category":"page"},{"location":"judge.html#JuDGE.@expansion","page":"JuDGE API","title":"JuDGE.@expansion","text":"expansion(model, variable, lag, span)\n\nDefines an expansion variable variable within a subproblem model. Note that all subproblems must have the same set of expansion variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available\n\nspan is the number of consecutive nodes in the scenario over which an expansion is available\n\nExamples\n\n@expansion(model, expand[1:5]) #defines an array of 5 variables with no lag, and unlimited lifespan\n@expansion(model, expand[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited lifespan\n@expansion(model, expand, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"judge.html#JuDGE.@shutdown","page":"JuDGE API","title":"JuDGE.@shutdown","text":"shutdown(model, variable, lag, span)\n\nDefines an shutdown variable variable within a subproblem model. Note that all subproblems must have the same set of shutdown variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the shutdown variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable\n\nspan is the number of consecutive nodes in the scenario over which the shutdown will last\n\nExamples\n\n@shutdown(model, shut[1:5]) #defines an array of 5 variables with no lag, and unlimited duration\n@shutdown(model, shut[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited duration\n@shutdown(model, shut, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"judge.html#JuDGE.@expansioncosts","page":"JuDGE API","title":"JuDGE.@expansioncosts","text":"expansioncosts(model, expr)\n\nDefines a linear expression specifying the cost of expansions and shutdowns at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the total cost of choosing expansion and shutdown variables at the current node\n\nExample\n\n@expansioncosts(model, sum(expand[i]*cost[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"judge.html#JuDGE.@maintenancecosts","page":"JuDGE API","title":"JuDGE.@maintenancecosts","text":"maintenancecosts(model, expr)\n\nDefines a linear expression specifying the ongoing cost of expansions and shutdowns available at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the ongoing cost of expansions and shutdowns available at the current node\n\nExample\n\n@maintenancecosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"judge.html#JuDGE.@sp_objective","page":"JuDGE API","title":"JuDGE.@sp_objective","text":"sp_objective(model, expr)\n\nDefines a linear expression specifying the cost of operating the system for the current node, excluding expansion or ongoing costs.\n\nIf it's possible to avoid costs by not using some previously expanded capacity, this can be included here with by directly including the expansion variable in the expression.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the subproblem costs.\n\nExample\n\n@sp_objective(model, sum(y[i]*c[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"tree.html#AbstractTree-API","page":"AbstractTree API","title":"AbstractTree API","text":"","category":"section"},{"location":"tree.html#Defining-Trees","page":"AbstractTree API","title":"Defining Trees","text":"","category":"section"},{"location":"tree.html","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.narytree\r\nJuDGE.tree_from_file\r\nJuDGE.tree_from_leaves\r\nJuDGE.print_tree","category":"page"},{"location":"tree.html#JuDGE.narytree","page":"AbstractTree API","title":"JuDGE.narytree","text":"narytree(depth::Int64, degree::Int64)\n\nGiven the depth and degree, this function returns an N-ary tree. Note that a depth of 0 return a single Leaf node (which is also the root node of the tree).\n\nRequired Arguments\n\ndepth is the maximum number of arcs from the root node any Leaf node\n\ndegree is the number of children of all nodes, other than the Leaf nodes\n\nExample\n\ntree = narytree(2,2)\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.tree_from_file","page":"AbstractTree API","title":"JuDGE.tree_from_file","text":"tree_from_file(filename::String)\n\nConstruct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node \"A\" to node \"B\". The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the data. Each column itself converted into a dictionary, indexed by the node.\n\nRequired Arguments\n\nstring is the full path of the file containing the tree\n\nExample\n\ntree, data = tree_from_file(joinpath(@__DIR__,\"tree.csv\"))\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.tree_from_leaves","page":"AbstractTree API","title":"JuDGE.tree_from_leaves","text":"tree_from_leaves(leafnodes::Array{Array{Int64,1},1}, probs::Array{Float64,1})\n\nConstruct tree from Array of leaf nodes, and (optionally) the corresponding probabilities\n\nRequired Arguments\n\nleafnodes is an array of arrays defining the set of leaf nodes\n\nOptional Arguments\n\nprobs is an array of probabilities for the leaf nodes\n\nExample\n\n(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])\ntree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.print_tree","page":"AbstractTree API","title":"JuDGE.print_tree","text":"print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Float64})\n\nGiven some_tree, this function prints a simple representation of the tree to the REPL.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise\n\nOptional Arguments\n\ndata is a dictionary indexed by the nodes of some_tree\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Nodes-of-Trees","page":"AbstractTree API","title":"Nodes of Trees","text":"","category":"section"},{"location":"tree.html","page":"AbstractTree API","title":"AbstractTree API","text":"Base.collect\r\nJuDGE.get_leafnodes\r\nJuDGE.get_node","category":"page"},{"location":"tree.html#Base.collect","page":"AbstractTree API","title":"Base.collect","text":"collect(tree::Tree;order=:depth)\n\nGiven tree, this function returns an array of corresponding nodes. By default this will be in a depth-first order.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect the nodes\n\nOptional Arguments\n\norder can be set to :depth or :breadth to specify the order that the nodes are listed in the array.\n\nExamples\n\nnodes = collect(tree) #gets an array of nodes from tree in depth-first order\nnodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.get_leafnodes","page":"AbstractTree API","title":"JuDGE.get_leafnodes","text":"get_leafnodes(tree::AbstractTree)\n\nGiven tree, this function returns an array of corresponding Leaf nodes.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect leaf nodes\n\nExample\n\nleafnodes = JuDGE.get_leafnodes(tree) #define a function that returns the parent of each node in the tree\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.get_node","page":"AbstractTree API","title":"JuDGE.get_node","text":"get_node(tree::AbstractTree, indices::Array{Int64,1})\n\nGiven a tree, and an array of indices, this function returns the corresponding node in the tree.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nindicies is an array of integer indices identifying a node within tree.\n\nExamples\n\nnode = get_node(tree,[1]) #get the root node\nnode = get_node(tree,[1,1]) #get the first child of the root node\nnode = get_node(tree,[1,2]) #get the second child of the root node\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Tree-Probabilities","page":"AbstractTree API","title":"Tree Probabilities","text":"","category":"section"},{"location":"tree.html","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.convert_probabilities\r\nJuDGE.ConditionallyUniformProbabilities\r\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"tree.html#JuDGE.convert_probabilities","page":"AbstractTree API","title":"JuDGE.convert_probabilities","text":"convert_probabilities(tree::AbstractTree, probabilities::Dict{AbstractTree,Float64})\n\nGiven a dictionary of conditional probabilities for each node in tree, this function returns a dictionary that maps each node of tree to the corresponding unconditional probability.\n\nRequired Arguments\n\ntree is the tree that the probabilities pertain to\n\nprobabilities is a dictionary of condition probabilities for each node in tree\n\nExample\n\nprobs = JuDGE.convert_probabilities(tree,probabilities)\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.ConditionallyUniformProbabilities","page":"AbstractTree API","title":"JuDGE.ConditionallyUniformProbabilities","text":"ConditionallyUniformProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = ConditionallyUniformProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.UniformLeafProbabilities","page":"AbstractTree API","title":"JuDGE.UniformLeafProbabilities","text":"UniformLeafProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = UniformLeafProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"tree.html#Other-Tree-functions","page":"AbstractTree API","title":"Other Tree functions","text":"","category":"section"},{"location":"tree.html","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.depth\r\nJuDGE.history\r\nJuDGE.parent_builder","category":"page"},{"location":"tree.html#JuDGE.depth","page":"AbstractTree API","title":"JuDGE.depth","text":"depth(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a subtree of tree and returns that subtree's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\ndepth_fn = JuDGE.history(tree) #define a function that returns the depth of each node in the tree\ndpth = depth_fn(node) #get the depth of node in tree\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.history","page":"AbstractTree API","title":"JuDGE.history","text":"history(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\nhistory_fn = JuDGE.history(tree) #define a function that returns the history of each node in the tree\n\npast = history_fn(node) #get a vector of nodes that precede node in tree\n\n\n\n\n\n","category":"function"},{"location":"tree.html#JuDGE.parent_builder","page":"AbstractTree API","title":"JuDGE.parent_builder","text":"parent_builder(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's parent.\n\nRequired Arguments\n\ntree is the tree that the parent function will correspond to.\n\nExample\n\nparent_fn = JuDGE.parent_builder(tree) #define a function that returns the parent of each node in the tree\np = parent_fn(node) #get the parent of node\n\n\n\n\n\n","category":"function"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"EditURL = \"<unknown>/F0PKY/docs/src/examples/01-knapsack-1bag.jl\"","category":"page"},{"location":"examples/01-knapsack-1bag.html#Knapsack-Problem-Single-Expansion","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"","category":"section"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This first example demonstrates how a basic JuDGE model can be set up, with a 7-node tree, and a single expansion.","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"using JuMP, JuDGE","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"First we will define our tree","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"mytree = narytree(2,2)","category":"page"},{"location":"examples/01-knapsack-1bag.html#Data","page":"Knapsack Problem - Single Expansion","title":"Data","text":"","category":"section"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Now we specify data for each node of the tree.","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"function invest_cost(node)\n   if node == get_node(mytree,[1])\n\t  180.0\n   elseif node == get_node(mytree,[1,1])\n\t  50.0\n   elseif node == get_node(mytree,[1,2])\n\t  60.0\n   elseif node == get_node(mytree,[1,1,1])\n\t  40.0\n   elseif node == get_node(mytree,[1,1,2])\n\t  60.0\n   elseif node == get_node(mytree,[1,2,1])\n\t  10.0\n   elseif node == get_node(mytree,[1,2,2])\n\t  10.0\n   end\nend\n\nfunction item_volume(node)\n   if node == get_node(mytree,[1])\n\t  [6, 2, 1, 1, 1]\n   elseif node == get_node(mytree,[1,1])\n\t  [8, 2, 2, 2, 1]\n   elseif node == get_node(mytree,[1,2])\n\t  [8, 1, 1, 1, 3]\n   elseif node == get_node(mytree,[1,1,1])\n\t  [4, 4, 3, 1, 2]\n   elseif node == get_node(mytree,[1,1,2])\n\t  [1, 3, 1, 1, 2]\n   elseif node == get_node(mytree,[1,2,1])\n\t  [7, 3, 1, 1, 1]\n   elseif node == get_node(mytree,[1,2,2])\n\t  [2, 5, 2, 1, 2]\n   end\nend\n\nfunction item_reward(node)\n   if node == get_node(mytree,[1])\n\t  [60, 20, 10, 15, 10]\n   elseif node == get_node(mytree,[1,1])\n\t  [8, 10, 20, 20, 10]\n   elseif node == get_node(mytree,[1,2])\n\t  [8, 10, 15, 10, 30]\n   elseif node == get_node(mytree,[1,1,1])\n\t  [40, 40, 35, 10, 20]\n   elseif node == get_node(mytree,[1,1,2])\n\t  [15, 35, 15, 15, 20]\n   elseif node == get_node(mytree,[1,2,1])\n\t  [70, 30, 15, 15, 10]\n   elseif node == get_node(mytree,[1,2,2])\n\t  [25, 50, 25, 15, 20]\n   end\nend","category":"page"},{"location":"examples/01-knapsack-1bag.html#Subproblems","page":"Knapsack Problem - Single Expansion","title":"Subproblems","text":"","category":"section"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"The JuDGE subproblems are defined through a function that takes a node as its single argument, returning a JuMP model.","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"function sub_problems(node)\n   model = Model(JuDGE_SP_Solver)\n   @expansion(model, bag)\n   @expansioncosts(model, bag*invest_cost(node))\n   @variable(model, y[1:5], Bin)\n   @constraint(model, BagExtension, sum(y[i]*item_volume(node)[i] for i in 1:5) <= 3 + 4 * bag)\n   @sp_objective(model, sum(-item_reward(node)[i] * y[i] for i in 1:5))\n   model\nend","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Note that there are a few JuDGE-specific macros used to define a JuDGE subproblem","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This defines our single expansion variable","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@expansion(model, bag)","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This defines the cost of buying this bag at particular node","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@expansioncosts(model, bag*invest_cost(node))","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Instead of using @objective, JuDGE models use:","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@sp_objective(model, sum(-item_reward(node)[i] * y[i] for i in 1:5))","category":"page"},{"location":"examples/01-knapsack-1bag.html#Defining-the-JuDGE-model","page":"Knapsack Problem - Single Expansion","title":"Defining the JuDGE model","text":"","category":"section"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"The JuDGEModel is defined based on a tree, probability distribution, sub_problems, and an optimizer","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"judy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Solve the model","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE.solve(judy)","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Print the objective, and optimal expansions","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"println(\"Objective: \"*string(objective_value(judy.master_problem)))\nJuDGE.print_expansions(judy,onlynonzero=false)","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Re-solve the subproblems and print the objective","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"println(\"Re-solved Objective: \" * string(resolve_subproblems(judy)))","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Set up and solve the deterministic equivalent","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"deteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)\nprintln(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"","category":"page"},{"location":"examples/01-knapsack-1bag.html","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"CurrentModule = JuDGE\r\nDocTestSetup = quote\r\n    using JuDGE\r\nend","category":"page"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"(Image: JuDGE)","category":"page"},{"location":"index.html#Getting-started","page":"JuDGE","title":"Getting started","text":"","category":"section"},{"location":"index.html#Requirements","page":"JuDGE","title":"Requirements","text":"","category":"section"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"JuDGE requires Julia-1.3+, JuMP and appropriate optimiser(s). For academics, Gurobi / CPLEX provide free academic licenses, otherwise, you can use CBC/Clp or GLPK.","category":"page"},{"location":"index.html#Installation","page":"JuDGE","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"JuDGE is installed by the Pkg utility provided by Julia. In the Julia REPL, simply make the following function call.","category":"page"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"] add \"https://github.com/reganbaucke/JuDGE.jl\"","category":"page"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"Then, in your Julia script, use","category":"page"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"using JuDGE","category":"page"},{"location":"index.html","page":"JuDGE","title":"JuDGE","text":"to import the functions from the JuDGE module into the current namespace.","category":"page"}]
}
