<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuDGE.jl: Julia Decomposition for Generalized Expansion</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuDGE.jl: Julia Decomposition for Generalized Expansion</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JuDGE</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#AbstractTree-Functions"><span>AbstractTree Functions</span></a></li><li><a class="tocitem" href="#JuDGE-Functions"><span>JuDGE Functions</span></a></li><li><a class="tocitem" href="#Deterministic-Equivalent"><span>Deterministic Equivalent</span></a></li><li><a class="tocitem" href="#Risk"><span>Risk</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="AbstractTree-Functions"><a class="docs-heading-anchor" href="#AbstractTree-Functions">AbstractTree Functions</a><a id="AbstractTree-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTree-Functions" title="Permalink"></a></h2><h3 id="Defining-Trees"><a class="docs-heading-anchor" href="#Defining-Trees">Defining Trees</a><a id="Defining-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Trees" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.narytree" href="#JuDGE.narytree"><code>JuDGE.narytree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">narytree(depth::Int, degree::Int)</code></pre><p>Given the <code>depth</code> and <code>degree</code>, this function returns an N-ary tree. Note that a depth of 0 return a single <code>Leaf</code> node (which is also the root node of the tree).</p><p><strong>Required Arguments</strong></p><p><code>depth</code> is the maximum number of arcs from the root node any <code>Leaf</code> node</p><p><code>degree</code> is the number of children of all nodes, other than the <code>Leaf</code> nodes</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">tree = narytree(2,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L828-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.tree_from_file" href="#JuDGE.tree_from_file"><code>JuDGE.tree_from_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tree_from_file(filename::String)</code></pre><p>Construct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node &quot;A&quot; to node &quot;B&quot;. The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the <code>data</code>. Each column itself converted into a dictionary, indexed by the node.</p><p><strong>Required Arguments</strong></p><p><code>string</code> is the full path of the file containing the tree</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">tree, data = tree_from_file(joinpath(@__DIR__,&quot;tree.csv&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L1088-L1103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.tree_from_leaves" href="#JuDGE.tree_from_leaves"><code>JuDGE.tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tree_from_leaves(leafnodes::Vector{Vector{Int}}, probs::Vector{Float64})</code></pre><p>Construct tree from Array of leaf nodes, and (optionally) the corresponding probabilities</p><p><strong>Required Arguments</strong></p><p><code>leafnodes</code> is an array of arrays defining the set of leaf nodes</p><p><strong>Optional Arguments</strong></p><p><code>probs</code> is an array of probabilities for the leaf nodes</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])
tree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L996-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.print_tree-Tuple{AbstractTree,Dict{AbstractTree,T} where T}" href="#JuDGE.print_tree-Tuple{AbstractTree,Dict{AbstractTree,T} where T}"><code>JuDGE.print_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Any})</code></pre><p>Given <code>some_tree</code>, this function prints a simple representation of the tree to the REPL.</p><p><strong>Required Arguments</strong></p><p><code>some_tree</code> is the tree we wish to visualise</p><p><strong>Optional Arguments</strong></p><p><code>data</code> is a dictionary indexed by each node in <code>some_tree</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L158-L168">source</a></section></article><h3 id="Nodes-of-Trees"><a class="docs-heading-anchor" href="#Nodes-of-Trees">Nodes of Trees</a><a id="Nodes-of-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-of-Trees" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.collect" href="#Base.collect"><code>Base.collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collect(tree::Tree;order::Symbol=:depth,truncate::Int=-1)</code></pre><p>Given <code>tree</code>, this function returns an array of corresponding nodes. By default this will be in a depth-first order.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we wish to collect the nodes</p><p><strong>Optional Arguments</strong></p><p><code>order</code> can be set to <code>:depth</code> or <code>:breadth</code> to specify the order that the nodes are listed in the array.</p><p><code>truncate</code> limits the nodes returned to a maximum depth of <code>truncate</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">nodes = collect(tree) #gets an array of nodes from tree in depth-first order
nodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L590-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_leafnodes" href="#JuDGE.get_leafnodes"><code>JuDGE.get_leafnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_leafnodes(tree::AbstractTree; truncate::Int = -1)</code></pre><p>Given <code>tree</code>, this function returns an array of corresponding <code>Leaf</code> nodes.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we wish to collect leaf nodes</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">leafnodes = JuDGE.get_leafnodes(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L644-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_node" href="#JuDGE.get_node"><code>JuDGE.get_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_node(tree::AbstractTree, indices::Vector{Int})</code></pre><p>Given a <code>tree</code>, and an array of <code>indices</code>, this function returns the corresponding node in the tree.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we are finding the node</p><p><code>indicies</code> is an array of integer indices identifying a node within <code>tree</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">node = get_node(tree,[1]) #get the root node
node = get_node(tree,[1,1]) #get the first child of the root node
node = get_node(tree,[1,2]) #get the second child of the root node</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L867-L881">source</a></section></article><h3 id="Tree-Probabilities"><a class="docs-heading-anchor" href="#Tree-Probabilities">Tree Probabilities</a><a id="Tree-Probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Probabilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.convert_probabilities" href="#JuDGE.convert_probabilities"><code>JuDGE.convert_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_probabilities(tree::AbstractTree, probabilities::Dict{NodeID,Float64})</code></pre><p>Given a dictionary of conditional probabilities for each node in <code>tree</code>, this function returns a dictionary that maps the <code>NodeID</code> of each node of <code>tree</code> to the corresponding unconditional probability.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree that the probabilities pertain to</p><p><code>probabilities</code> is a dictionary of condition probabilities for each node in <code>tree</code></p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">probs = JuDGE.convert_probabilities(tree,probabilities)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L733-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.ConditionallyUniformProbabilities" href="#JuDGE.ConditionallyUniformProbabilities"><code>JuDGE.ConditionallyUniformProbabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ConditionallyUniformProbabilities(tree::AbstractTree)</code></pre><p>Given a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree for which the probability distribution will be generated</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">probs = ConditionallyUniformProbabilities(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L673-L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.UniformLeafProbabilities" href="#JuDGE.UniformLeafProbabilities"><code>JuDGE.UniformLeafProbabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">UniformLeafProbabilities(tree::AbstractTree)</code></pre><p>Given a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree for which the probability distribution will be generated</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">probs = UniformLeafProbabilities(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L700-L710">source</a></section></article><h3 id="Other-Tree-functions"><a class="docs-heading-anchor" href="#Other-Tree-functions">Other Tree functions</a><a id="Other-Tree-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Tree-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.depth" href="#JuDGE.depth"><code>JuDGE.depth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">depth(tree::AbstractTree)</code></pre><p>Given <code>tree</code>, this function returns the depth. The root node has a depth of 0.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the node we wish to find the depth for.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">depth = JuDGE.depth(tree) #returns the depth of a node in a tree</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L767-L778">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.history" href="#JuDGE.history"><code>JuDGE.history</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">history(tree::AbstractTree)</code></pre><p>Given <code>tree</code>, this function returns the history back up to the root node of <code>tree</code>.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the node that we wish to find the history for.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">history = JuDGE.history(tree) #get a vector of nodes that precede tree</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L783-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.visualize_tree" href="#JuDGE.visualize_tree"><code>JuDGE.visualize_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">visualize_tree(some_tree::AbstractTree,
    data::Dict{AbstractTree,Dict{Symbol,Any}};
    scale_edges = nothing,
    scale_nodes::Float64 = 0.0,
    max_size::Float64 = 50.0,
    custom::Union{Nothing,Dict{Symbol,Tuple{String,String,String}}} = nothing,
    truncate::Int = -1)</code></pre><p>Given <code>some_tree</code>, this function generates a html/js visualization of the tree.</p><p><strong>Required Arguments</strong></p><p><code>some_tree</code> is the tree we wish to visualise.</p><p><code>data</code> is a dictionary of the data we wish to display, each element is a dictionary for a node of the tree, indexed by the Symbols.</p><p><strong>Optional Arguments</strong></p><p><code>scale_edges</code> this is the scale factor for edges as the network gets deeper.</p><p><code>scale_nodes</code> this is the scale factor for nodes as the network gets deeper.</p><p><code>max_size</code> this is the size of the root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L218-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_groups" href="#JuDGE.get_groups"><code>JuDGE.get_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_groups(tree::AbstractTree; combine=0)</code></pre><p>Given a <code>tree</code>, this function will split it up into an array of subtrees. These can be provided as <code>blocks</code> for the <code>JuDGE.solve()</code> function to perform partial pricing.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we are finding the node</p><p><strong>Optional Arguments</strong></p><p><code>combine</code> this parameter determines the size of the subtrees (higher creates larger subtrees). If set to 0, the subtrees will be the sets of paths to the leaf nodes.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">blocks = get_groups(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/tree.jl#L890-L905">source</a></section></article><h2 id="JuDGE-Functions"><a class="docs-heading-anchor" href="#JuDGE-Functions">JuDGE Functions</a><a id="JuDGE-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-Functions" title="Permalink"></a></h2><h3 id="JuDGE-Solving-Functions"><a class="docs-heading-anchor" href="#JuDGE-Solving-Functions">JuDGE Solving Functions</a><a id="JuDGE-Solving-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-Solving-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.JuDGEModel" href="#JuDGE.JuDGEModel"><code>JuDGE.JuDGEModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JuDGEModel(tree::AbstractTree,
           probabilities,
           sub_problem_builder::Function,
           solver;
           discount_factor=1.0,
           risk=RiskNeutral(),
           sideconstraints=nothing,
           check=true,
           perfect_foresight=false)</code></pre><p>Define a JuDGE model.</p><p><strong>Required arguments</strong></p><p><code>tree</code> is a reference to a scenario tree</p><p><code>probabilities</code> is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself</p><p><code>sub_problem_builder</code> is a function mapping a node to a JuMP model for each subproblems</p><p><code>solver</code> is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)</p><p><strong>Optional arguments</strong></p><p><code>discount_factor</code> is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree</p><p><code>risk</code> can be either a <code>Risk</code> object, or a vector of such objects.</p><p><code>sideconstraints</code> is a function which specifies side constraints in the master problem, see <a href="../tutorials/#Tutorial-9:-Side-constraints">Tutorial 9: Side-constraints</a> for further details</p><p><code>check</code> is a boolean, which can be set to <code>false</code> to disable the validation of the JuDGE model.</p><p><code>perfect_foresight</code> is a boolean; this is an experimental feature, which creates an array of JuDGE models, one for each leaf node. This will enable users to easily compute the EVPI for the stochastic program. Also can be used for regret-based risk implementations. See the example EVPI<em>and</em>VSS.jl.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">judge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,
                                Gurobi.Optimizer)
judge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,
                                discount_factor=0.9, risk=Risk(0.5,0.1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/JuDGE.jl#L72-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.solve-Tuple{JuDGEModel}" href="#JuDGE.solve-Tuple{JuDGEModel}"><code>JuDGE.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(judge::JuDGEModel;
      termination::Termination=Termination(),
      max_no_int::Int=typemax(Int),
      blocks::Union{Nothing,Vector{Vector{AbstractTree}}}=nothing,
      warm_starts::Bool=false,
      optimizer_attributes::Union{Nothing,Function}=nothing,
      mp_callback::Union{Nothing,Function}=nothing,
      prune::Float64=Inf,
      heuristic::Union{Nothing,Function}=nothing,
      verbose::Int=2)</code></pre><p>Solve a JuDGEModel <code>judge</code> without branch-and-price.</p><p><strong>Required Arguments</strong></p><p><code>judge</code> is the JuDGE model that we wish to solve.</p><p><strong>Optional Arguments</strong></p><p><code>termination</code> is a <code>Termination</code> object containing all the stopping conditions.</p><p><code>max_no_int</code> is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the <code>relgap</code> / <code>absgap</code> stopping conditions. To override this, set <code>max_no_int</code> to the negative of the number desired value.</p><p><code>blocks</code> specifies the groups of nodes to solve in each iteration (these groups can be generated using <code>JuDGE.get_groups()</code>, or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See <code>advanced.jl</code> for more details.</p><p><code>warm_starts</code> boolean specifing whether to use warm starts for subproblems and binary solves of master problem.</p><p><code>optimizer_attributes</code> can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the <code>advanced.jl</code> example.</p><p><code>mp_callback</code> is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.</p><p><code>prune</code> is used to stop the algorithm before convergence, if a known upper bound for the problem is specified.</p><p><code>heuristic</code> is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.</p><p><code>verbose</code> if 0, all output from solve will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">JuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6))
JuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6), max_no_int=-5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/JuDGE.jl#L410-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.branch_and_price" href="#JuDGE.branch_and_price"><code>JuDGE.branch_and_price</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">branch_and_price(models::Union{JuDGEModel,Vector{JuDGEModel}};
	branch_method::Function=JuDGE.variable_branch,search::Symbol=:lowestLB,
	termination::Termination=Termination(),
	max_no_int::Int=typemax(Int),
	blocks::Union{Nothing,Vector{Vector{AbstractTree}}}=nothing,
	warm_starts::Bool=false,
	optimizer_attributes::Union{Nothing,Function}=nothing,
	mp_callback::Union{Nothing,Function}=nothing,
	bp_callback::Union{Nothing,Function}=nothing,
	heuristic::Union{Nothing,Function}=nothing,
	verbose::Int=2)</code></pre><p>Solve a JuDGEModel <code>judge</code> without branch and price.</p><p><strong>Required Arguments</strong></p><p><code>judge</code> is the JuDGE model that we wish to solve.</p><p><strong>Optional Arguments</strong></p><p><code>branch_method</code> is a function specifies the way that constraints are added to create new nodes in the branch<em>and</em>price tree.</p><p><code>search</code> specifies the order in which nodes are solved in the (branch-and-price) tree. Options are: <code>:lowestLB</code>, <code>:depth_first_dive</code>, <code>:depth_first_resurface</code>, <code>:breadth_first</code>.</p><p><code>termination</code> is a <code>Termination</code> object containing all the stopping conditions.</p><p><code>max_no_int</code> is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the <code>relgap</code> / <code>absgap</code> stopping conditions. To override this, set <code>max_no_int</code> to the negative of the number desired value.</p><p><code>blocks</code> specifies the groups of nodes to solve in each iteration (these groups can be generated using <code>JuDGE.get_groups()</code>, or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See <code>advanced.jl</code> for more details.</p><p><code>warm_starts</code> boolean specifing whether to use warm starts for subproblems and binary solves of master problem.</p><p><code>optimizer_attributes</code> can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the <code>advanced.jl</code> example.</p><p><code>mp_callback</code> is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.</p><p><code>bp_callback</code> is a user-defined function that allows you to modify the <code>Termination</code> conditions for <code>JuDGE.solve</code> and the <code>search</code> policy during the branch-and-price process.</p><p><code>heuristic</code> is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.</p><p><code>verbose</code> if 0, most output from <code>JuDGE.solve</code> will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">JuDGE.branch_and_price(jmodel, termination=Termination(abstol=10^-6))
JuDGE.branch_and_price(jmodel, search=:depth_first_dive, verbose=0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/branchandprice.jl#L241-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.Termination" href="#JuDGE.Termination"><code>JuDGE.Termination</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Termination(;abstol::Float64=10^-9,             reltol::Float64=10^-9,             rlx<em>abstol::Float64=10^-9,             rlx</em>reltol::Float64=10^-9,             time<em>limit::Float64=Inf,             max</em>iter::Int=typemax(Int),             inttol::Float64=10^-8,             allow<em>frac::Symbol=:binary</em>solve)</p><p>Define the stopping conditions for <code>JuDGE.solve()</code> / <code>JuDGE.branch_and_price()</code>.</p><p><strong>Optional Arguments</strong></p><p><code>abstol</code> is the absolute tolerance for the best integer-feasible objective value and the lower bound.</p><p><code>reltol</code> is the relative tolerance for the best integer-feasible objective value and the lower bound.</p><p><code>rlx_abstol</code> is the absolute tolerance for the relaxed master objective value and the lower bound.</p><p><code>rlx_reltol</code> is the relative tolerance for the relaxed master objective value and the lower bound.</p><p><code>time_limit</code> is the maximum duration in seconds.</p><p><code>max_iter</code> is the maximum number of iterations.</p><p><code>inttol</code> is the maximum deviation from 0 or 1 for any binary/integer variable for integer feasible solutions.</p><p><code>allow_frac</code> indicates whether a fractional solution will be returned; possible values are:     <code>:binary_solve</code> a binary solve of master will be performed (if needed) prior to the solution being returned;     <code>:binary_solve_return_relaxation</code> a binary solve of master will be performed (if needed), updating the upper bound,     but the master problem relation will be returned;     <code>:first_fractional</code> will return the first fractional master solution found;     <code>:no_binary_solve</code> will simply return the solution to the relaxed master problem when terminated.</p><p><strong>Examples</strong></p><p>Termination(rlx_abstol=10^-6)    Termination(abstol=10^-3,inttol=10^-6)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/convergence.jl#L60-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.variable_branch" href="#JuDGE.variable_branch"><code>JuDGE.variable_branch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">variable_branch(jmodel::JuDGEModel, inttol::Float64)</code></pre><p>This is an in-built function that is called during branch-and-price to perform a branch. Users can define their own functions that follow this format to create new branching strategies.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model</p><p><code>inttol</code> is the maximum permitted deviation from binary/integer for a value to still be considered binary/integer feasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/branchandprice.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.resolve_subproblems" href="#JuDGE.resolve_subproblems"><code>JuDGE.resolve_subproblems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resolve_subproblems(judge::JuDGEModel)</code></pre><p>Once a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model that we wish to solve.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">resolve_subproblems(judge)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/JuDGE.jl#L978-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.set_policy!" href="#JuDGE.set_policy!"><code>JuDGE.set_policy!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set_policy!(     jmodel::JuDGEModel,     jmodel2::JuDGEModel,     mapping::Union{Symbol,Dict{AbstractTree,AbstractTree}})</p><p>Fixes the policy of a JuDGEModel object based on another JuDGEModel object.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model for which we wish to set the policy. <code>jmodel2</code> is the JuDGE model from which we wish to copy the policy. <code>mapping</code> is can either be set to the symbol <code>:by_depth</code> or <code>:by_nodeID</code> or be an explicit dictionary mapping the nodes in <code>jmodel.tree</code> the nodes in <code>jmodel2.tree</code>. For any node in <code>jmodel.tree</code> that is not mapped, no policy is set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/JuDGE.jl#L1093-L1107">source</a></section></article><h3 id="JuDGE-Macros-for-Subproblems"><a class="docs-heading-anchor" href="#JuDGE-Macros-for-Subproblems">JuDGE Macros for Subproblems</a><a id="JuDGE-Macros-for-Subproblems-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-Macros-for-Subproblems" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@expansion" href="#JuDGE.@expansion"><code>JuDGE.@expansion</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">expansion(model, variable, args...)</code></pre><p>Defines an expansion variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of expansion variables.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the expansion variable to</p><p><code>variable</code> is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>lag</code> is the number of nodes in the scenario between an expansion being decided, and it becoming available.</p><p><code>duration</code> is the number of consecutive nodes in the scenario over which an expansion is available.</p><p><code>lb</code> is the lower bound for this variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for this variable in the master problem (typically omitted).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@expansion(model, expand[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan
@expansion(model, expand[1:5,1:2]&gt;=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration
@expansion(model, 0&lt;=expand&lt;=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/macros.jl#L122-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@shutdown" href="#JuDGE.@shutdown"><code>JuDGE.@shutdown</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">shutdown(model, variable, args...)</code></pre><p>Defines an shutdown variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of shutdown variables.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the shutdown variable to</p><p><code>variable</code> is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>lag</code> is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable.</p><p><code>duration</code> is the number of consecutive nodes in the scenario over which the shutdown will last.</p><p><code>lb</code> is the lower bound for this variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for this variable in the master problem (typically omitted).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@shutdown(model, shut[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan
@shutdown(model, shut[1:5,1:2]&gt;=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration
@shutdown(model, 0&lt;=shut&lt;=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/macros.jl#L165-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@enforced" href="#JuDGE.@enforced"><code>JuDGE.@enforced</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">enforced(model, variable, args...)</code></pre><p>Defines an enforced variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of enforced variables. These variables can be used as either expansion or shutdown variables, but since the constraint in the master problem is an equality, convergence is more difficult since there is less flexibility when solving the master problem.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the expansion variable to</p><p><code>variable</code> is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>lag</code> is the number of nodes in the scenario between an expansion being decided, and it becoming available.</p><p><code>duration</code> is the number of consecutive nodes in the scenario over which an expansion is available.</p><p><code>lb</code> is the lower bound for this variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for this variable in the master problem (typically omitted).</p><p><code>penalty</code> is a placeholder for a future feature, which may allow the violation of master/subproblem equality constraint, at a cost.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@expansion(model, forced[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan
@expansion(model, forced[1:5,1:2]&gt;=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration
@expansion(model, 0&lt;=forced&lt;=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/macros.jl#L208-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@state" href="#JuDGE.@state"><code>JuDGE.@state</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">state(model, variable, args...)</code></pre><p>Defines a state variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of state variables. These variables can be used to model inventory that is carried forward between the subproblems.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the expansion variable to</p><p><code>variable</code> is the name of the variable being created in the subproblem, this will be continuous by default; follows JuMP syntax if defining a set of variables. The subproblem variable corresponds to the change in the state.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>state_name</code> is the name for the state variable in the master problem. If omitted, the name of the master problem variable will match the subproblem variable (but this may cause confusion, since only the master problem variable is the state). See the <code>inventory.jl</code> example to see how this should be implemented.</p><p><code>initial</code> is the initial value for the master problem&#39;s state variable at the root node.</p><p><code>lb</code> is the lower bound for the variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for the variable in the master problem (typically omitted).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@state(sp, -50&lt;=Δstock&lt;=50, state_name=stock, lb=0, ub=200, initial=0) #defines a state variable called stock in the master
                                                                       #(starting at 0, and able to take values 0 to 200),
                                                                       #and Δstock in the subproblem (able to change the stock level by ±50).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/macros.jl#L255-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@capitalcosts" href="#JuDGE.@capitalcosts"><code>JuDGE.@capitalcosts</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">capitalcosts(model, expr)</code></pre><p>Defines a linear expression specifying the capital cost of expansions and shutdowns at the current node</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for</p><p><code>expr</code> is an <code>AffExpr</code> which gives the total cost of choosing expansion and shutdown variables at the current node</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@capitalcosts(model, sum(expand[i]*cost[node][i] for i in 1:5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/macros.jl#L302-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@ongoingcosts" href="#JuDGE.@ongoingcosts"><code>JuDGE.@ongoingcosts</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">ongoingcosts(model, expr)</code></pre><p>Defines a linear expression specifying the ongoing costs of expansions and shutdowns available at the current node</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for</p><p><code>expr</code> is an <code>AffExpr</code> which gives the ongoing cost of expansions and shutdowns available at the current node</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">@ongoingcosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/macros.jl#L334-L346">source</a></section></article><h3 id="JuDGE-Solutions-/-Output"><a class="docs-heading-anchor" href="#JuDGE-Solutions-/-Output">JuDGE Solutions / Output</a><a id="JuDGE-Solutions-/-Output-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-Solutions-/-Output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.solution_to_dictionary-Tuple{JuDGEModel}" href="#JuDGE.solution_to_dictionary-Tuple{JuDGEModel}"><code>JuDGE.solution_to_dictionary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution_to_dictionary(jmodel::JuDGEModel; prefix::String = &quot;&quot;)</code></pre><p>Create a nested dictionary with the solution values for each node copied across to a standardised structure.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is a solved JuDGEModel</p><p><strong>Optional Arguments</strong></p><p><code>prefix</code> is a string that will be prepended to each of the variable names (e.g. if comparing to versions of the same model)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/utilities.jl#L259-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_active_columns-Tuple{JuDGEModel}" href="#JuDGE.get_active_columns-Tuple{JuDGEModel}"><code>JuDGE.get_active_columns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_active_columns(jmodel::JuDGEModel; inttol = 10^-7)</code></pre><p>Returns a list of tuples of non-zero columns along with their corresponding value.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is a solved JuDGEModel</p><p><strong>Optional Arguments</strong></p><p><code>inttol</code> is the minimum value for a variable to be deemed non-zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/utilities.jl#L543-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}" href="#JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}"><code>JuDGE.write_solution_to_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_solution_to_file(model::Union{JuDGEModel,DetEqModel},filename::String)</code></pre><p>Given a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.</p><p><strong>Required Arguments</strong></p><p><code>model</code> can be either the <code>JuDGEModel</code> or the <code>DetEqModel</code> whose solution we wish to write to a file</p><p><code>filename</code> is the output filename</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/output.jl#L339-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.print_expansions-Tuple{JuDGEModel}" href="#JuDGE.print_expansions-Tuple{JuDGEModel}"><code>JuDGE.print_expansions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_expansions(jmodel::JuDGEModel;
                 onlynonzero::Bool=true,
                 inttol=10^-9,
                 format=nothing)</code></pre><p>Given a solved JuDGE model, this function will write the optimal capacity expansion decisions to the REPL.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model whose solution we wish to write to a file</p><p><strong>Optional Arguments</strong></p><p><code>onlynonzero</code> is a boolean, if set to <code>true</code> the function will only print expansions with a non-zero value.</p><p><code>inttol</code> is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-<code>inttol</code> will be treated as 1</p><p><code>format</code> is a function that specifies customised printing of expansion values. See <a href="../tutorials/#Tutorial-2:-Formatting-output">Tutorial 2: Formatting output</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/output.jl#L21-L42">source</a></section></article><h2 id="Deterministic-Equivalent"><a class="docs-heading-anchor" href="#Deterministic-Equivalent">Deterministic Equivalent</a><a id="Deterministic-Equivalent-1"></a><a class="docs-heading-anchor-permalink" href="#Deterministic-Equivalent" title="Permalink"></a></h2><h3 id="Define-and-Solve-DetEq-Model"><a class="docs-heading-anchor" href="#Define-and-Solve-DetEq-Model">Define and Solve DetEq Model</a><a id="Define-and-Solve-DetEq-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Define-and-Solve-DetEq-Model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.DetEqModel" href="#JuDGE.DetEqModel"><code>JuDGE.DetEqModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DetEqModel(tree::AbstractTree,
           probabilities,
           sub_problem_builder::Function,
           solver
           discount_factor=1.0,
           risk=RiskNeutral,
           sideconstraints=nothing,
           check=true)</code></pre><p>Define a deterministic equivalent model for the stochastic capacity expansion problem.</p><p><strong>Required arguments</strong></p><p><code>tree</code> is a reference to a scenario tree</p><p><code>probabilities</code> is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself</p><p><code>sub_problem_builder</code> is a function mapping a node to a JuMP model for each subproblems</p><p><code>solver</code> is a reference to the optimizer used for this problem (with appropriate settings)</p><p><strong>Optional arguments</strong></p><p><code>discount_factor</code> is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree</p><p><code>risk</code> is a tuple with the two CVaR parameters: (λ, α)</p><p><code>sideconstraints</code> is a function which specifies side constraints in the master problem, see <a href="../tutorials/#Tutorial-9:-Side-constraints">Tutorial 9: Side-constraints</a> for further details.</p><p><code>check</code> is a boolean, which can be set to <code>false</code> to disable the validation of the JuDGE model.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">deteq = DetEqModel(tree, ConditionallyUniformProbabilities, sub_problems,
                                Gurobi.Optimizer)
judge = DetEqModel(tree, probabilities, sub_problems, CPLEX.Optimizer,
                                discount_factor=0.9, risk=(0.5,0.1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/deteq.jl#L13-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.solve-Tuple{DetEqModel}" href="#JuDGE.solve-Tuple{DetEqModel}"><code>JuDGE.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(deteq::DetEqModel)</code></pre><p>Solve a determinisitc equivalent model.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is the determinisitc equivalent model that we wish to solve.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">JuDGE.solve(deteq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/deteq.jl#L565-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.set_starting_solution!" href="#JuDGE.set_starting_solution!"><code>JuDGE.set_starting_solution!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_starting_solution!(deteq::DetEqModel, jmodel::JuDGEModel)</code></pre><p>Use the best solution from a JuDGEModel to warm start the deterministic equivalent.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is an unsolved DetEqModel <code>jmodel</code> is a solved JuDGEModel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/utilities.jl#L440-L448">source</a></section></article><h3 id="DetEq-Solutions-/-Output"><a class="docs-heading-anchor" href="#DetEq-Solutions-/-Output">DetEq Solutions / Output</a><a id="DetEq-Solutions-/-Output-1"></a><a class="docs-heading-anchor-permalink" href="#DetEq-Solutions-/-Output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.solution_to_dictionary-Tuple{DetEqModel}" href="#JuDGE.solution_to_dictionary-Tuple{DetEqModel}"><code>JuDGE.solution_to_dictionary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution_to_dictionary(deteq::DetEqModel; prefix::String = &quot;&quot;)</code></pre><p>Create a nested dictionary with the solution values for each node copied across to a standardised structure.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is a solved DetEqModel</p><p><strong>Optional Arguments</strong></p><p><code>prefix</code> is a string that will be prepended to each of the variable names (e.g. if comparing to versions of the same model)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/utilities.jl#L357-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.write_solution_to_file-Tuple{DetEqModel,String}" href="#JuDGE.write_solution_to_file-Tuple{DetEqModel,String}"><code>JuDGE.write_solution_to_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_solution_to_file(model::Union{JuDGEModel,DetEqModel},filename::String)</code></pre><p>Given a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.</p><p><strong>Required Arguments</strong></p><p><code>model</code> can be either the <code>JuDGEModel</code> or the <code>DetEqModel</code> whose solution we wish to write to a file</p><p><code>filename</code> is the output filename</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/output.jl#L339-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.print_expansions-Tuple{DetEqModel}" href="#JuDGE.print_expansions-Tuple{DetEqModel}"><code>JuDGE.print_expansions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_expansions(deteq::DetEqModel;
                 onlynonzero::Bool=true,
                 inttol=10^-9,
                 format=nothing)</code></pre><p>Given a solved deterministic equivalent model, this function will write the optimal capacity expansion decisions to the REPL.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is the deterministic equivalent model whose solution we wish to write to a file</p><p><strong>Optional Arguments</strong></p><p><code>onlynonzero</code> is a boolean, if set to <code>true</code> the function will only print expansions with a non-zero value.</p><p><code>inttol</code> is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-<code>inttol</code> will be treated as 1</p><p><code>format</code> is a function that specifies customised printing of expansion values. See <a href="../tutorials/#Tutorial-2:-Formatting-output">Tutorial 2: Formatting output</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/output.jl#L162-L183">source</a></section></article><h2 id="Risk"><a class="docs-heading-anchor" href="#Risk">Risk</a><a id="Risk-1"></a><a class="docs-heading-anchor-permalink" href="#Risk" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuDGE.RiskNeutral-Tuple{}" href="#JuDGE.RiskNeutral-Tuple{}"><code>JuDGE.RiskNeutral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RiskNeutral()</code></pre><p>Create a risk-neutral risk measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/risk.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.Risk-Tuple{Float64,Float64}" href="#JuDGE.Risk-Tuple{Float64,Float64}"><code>JuDGE.Risk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Risk(λ::Float64,
     α::Float64;
     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,
     bound::Union{Float64,Nothing}=nothing,
     penalty::Float64=100000.0)</code></pre><p>Define the CVaR risk measure to be applied to the accumulated profits at the leaf nodes.</p><p><strong>Required Arguments</strong></p><p><code>λ</code> is weighting applied for the risk measure (max sum of weightings should be 1.0), if sum of weightings is less than 1.0, expected value will make up the rest.</p><p><code>α</code> is the probability in the tail of the distribution</p><p><strong>Optional Arguments</strong></p><p><code>offset</code> applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.</p><p><code>bound</code> if used, this will create a constraint on CVaR(α) with this as the upper bound.</p><p><code>penalty</code> if a constraint on CVaR is applied, then the marginal cost of violating the constraint is <code>penalty</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/risk.jl#L18-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.Risk-Tuple{Float64}" href="#JuDGE.Risk-Tuple{Float64}"><code>JuDGE.Risk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Risk(α::Float64;
     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,
     bound::Union{Float64,Nothing}=nothing,
     penalty::Float64=100000.0)</code></pre><p>Define the CVaR risk constraint to be applied to the accumulated profits at the leaf nodes.</p><p><strong>Required Arguments</strong></p><p><code>α</code> is the probability in the tail of the distribution</p><p><strong>Optional Arguments</strong></p><p><code>offset</code> applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.</p><p><code>bound</code> if used, this will create a constraint on CVaR(α) with this as the upper bound.</p><p><code>penalty</code> if a constraint on CVaR is applied, then the marginal cost of violating the constraint is <code>penalty</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/risk.jl#L57-L76">source</a></section></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuDGE.remove_from_dictionary!" href="#JuDGE.remove_from_dictionary!"><code>JuDGE.remove_from_dictionary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_from_dictionary!(
    original::Dict{AbstractTree,Dict{Symbol,Any}},
    sym::Union{Symbol,Vector{Symbol}})</code></pre><p>Given a dictionary produced by the <code>solution_to_dictionary()</code> function, and a Symbol or Symbol[], this function removes that/those Symbol(s) from the dictionary.</p><p><strong>Required Arguments</strong></p><p><code>original</code> is a dictionary produced by <code>solution_to_dictionary()</code> <code>sym</code> is a Symbol or Symbol vector of keys to remove from each node within the dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/utilities.jl#L514-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.add_to_dictionary!" href="#JuDGE.add_to_dictionary!"><code>JuDGE.add_to_dictionary!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_to_dictionary!(
    original::Dict{AbstractTree,Dict{Symbol,Any}},
    sym::Union{Symbol,Vector{Symbol}})</code></pre><p>Given a dictionary produced by the <code>solution_to_dictionary()</code> function, and a Symbol or Symbol[], this function adds that/those Symbol(s) to the dictionary.</p><p><strong>Required Arguments</strong></p><p><code>original</code> is a dictionary produced by <code>solution_to_dictionary()</code> <code>sym</code> is a Symbol or Symbol vector of keys to add to each node within the dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EPOC-UoA/JuDGE.jl/blob/a8ef813c7ade8aed6b00560781613039ccd922b9/src/utilities.jl#L479-L490">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/">« Tutorials</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.8 on <span class="colophon-date" title="Saturday 16 October 2021 03:16">Saturday 16 October 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
