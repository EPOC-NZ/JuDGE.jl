<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuDGE.jl: Julia Decomposition for Generalized Expansion</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JuDGE.jl: Julia Decomposition for Generalized Expansion</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JuDGE</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#AbstractTree-Functions"><span>AbstractTree Functions</span></a></li><li><a class="tocitem" href="#JuDGE-Functions"><span>JuDGE Functions</span></a></li><li><a class="tocitem" href="#Deterministic-Equivalent"><span>Deterministic Equivalent</span></a></li><li><a class="tocitem" href="#Risk"><span>Risk</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/reganbaucke/JuDGE.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="AbstractTree-Functions"><a class="docs-heading-anchor" href="#AbstractTree-Functions">AbstractTree Functions</a><a id="AbstractTree-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTree-Functions" title="Permalink"></a></h2><h3 id="Defining-Trees"><a class="docs-heading-anchor" href="#Defining-Trees">Defining Trees</a><a id="Defining-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Trees" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.narytree" href="#JuDGE.narytree"><code>JuDGE.narytree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">narytree(depth::Int, degree::Int)</code></pre><p>Given the <code>depth</code> and <code>degree</code>, this function returns an N-ary tree. Note that a depth of 0 return a single <code>Leaf</code> node (which is also the root node of the tree).</p><p><strong>Required Arguments</strong></p><p><code>depth</code> is the maximum number of arcs from the root node any <code>Leaf</code> node</p><p><code>degree</code> is the number of children of all nodes, other than the <code>Leaf</code> nodes</p><p><strong>Example</strong></p><pre><code class="language-none">tree = narytree(2,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L721-L733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.tree_from_file" href="#JuDGE.tree_from_file"><code>JuDGE.tree_from_file</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tree_from_file(filename::String)</code></pre><p>Construct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node &quot;A&quot; to node &quot;B&quot;. The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the <code>data</code>. Each column itself converted into a dictionary, indexed by the node.</p><p><strong>Required Arguments</strong></p><p><code>string</code> is the full path of the file containing the tree</p><p><strong>Example</strong></p><pre><code class="language-none">tree, data = tree_from_file(joinpath(@__DIR__,&quot;tree.csv&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L991-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.tree_from_leaves" href="#JuDGE.tree_from_leaves"><code>JuDGE.tree_from_leaves</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tree_from_leaves(leafnodes::Array{Array{Int,1},1}, probs::Array{Float64,1})</code></pre><p>Construct tree from Array of leaf nodes, and (optionally) the corresponding probabilities</p><p><strong>Required Arguments</strong></p><p><code>leafnodes</code> is an array of arrays defining the set of leaf nodes</p><p><strong>Optional Arguments</strong></p><p><code>probs</code> is an array of probabilities for the leaf nodes</p><p><strong>Example</strong></p><pre><code class="language-none">(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])
tree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L864-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.print_tree-Tuple{AbstractTree,Dict{AbstractTree,T} where T}" href="#JuDGE.print_tree-Tuple{AbstractTree,Dict{AbstractTree,T} where T}"><code>JuDGE.print_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Any})</code></pre><p>Given <code>some_tree</code>, this function prints a simple representation of the tree to the REPL.</p><p><strong>Required Arguments</strong></p><p><code>some_tree</code> is the tree we wish to visualise</p><p><strong>Optional Arguments</strong></p><p><code>data</code> is a dictionary indexed by each node in <code>some_tree</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L157-L167">source</a></section></article><h3 id="Nodes-of-Trees"><a class="docs-heading-anchor" href="#Nodes-of-Trees">Nodes of Trees</a><a id="Nodes-of-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes-of-Trees" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.collect" href="#Base.collect"><code>Base.collect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect(tree::Tree;order=:depth)</code></pre><p>Given <code>tree</code>, this function returns an array of corresponding nodes. By default this will be in a depth-first order.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we wish to collect the nodes</p><p><strong>Optional Arguments</strong></p><p><code>order</code> can be set to <code>:depth</code> or <code>:breadth</code> to specify the order that the nodes are listed in the array.</p><p><strong>Examples</strong></p><pre><code class="language-none">nodes = collect(tree) #gets an array of nodes from tree in depth-first order
nodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L490-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_leafnodes" href="#JuDGE.get_leafnodes"><code>JuDGE.get_leafnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_leafnodes(tree::AbstractTree)</code></pre><p>Given <code>tree</code>, this function returns an array of corresponding <code>Leaf</code> nodes.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we wish to collect leaf nodes</p><p><strong>Example</strong></p><pre><code class="language-none">leafnodes = JuDGE.get_leafnodes(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L541-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_node" href="#JuDGE.get_node"><code>JuDGE.get_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_node(tree::AbstractTree, indices::Array{Int,1})</code></pre><p>Given a <code>tree</code>, and an array of <code>indices</code>, this function returns the corresponding node in the tree.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we are finding the node</p><p><code>indicies</code> is an array of integer indices identifying a node within <code>tree</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">node = get_node(tree,[1]) #get the root node
node = get_node(tree,[1,1]) #get the first child of the root node
node = get_node(tree,[1,2]) #get the second child of the root node</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L760-L774">source</a></section></article><h3 id="Tree-Probabilities"><a class="docs-heading-anchor" href="#Tree-Probabilities">Tree Probabilities</a><a id="Tree-Probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Probabilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.convert_probabilities" href="#JuDGE.convert_probabilities"><code>JuDGE.convert_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert_probabilities(tree::AbstractTree, probabilities::Dict{NodeID,Float64})</code></pre><p>Given a dictionary of conditional probabilities for each node in <code>tree</code>, this function returns a dictionary that maps the <code>NodeID</code> of each node of <code>tree</code> to the corresponding unconditional probability.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree that the probabilities pertain to</p><p><code>probabilities</code> is a dictionary of condition probabilities for each node in <code>tree</code></p><p><strong>Example</strong></p><pre><code class="language-none">probs = JuDGE.convert_probabilities(tree,probabilities)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L626-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.ConditionallyUniformProbabilities" href="#JuDGE.ConditionallyUniformProbabilities"><code>JuDGE.ConditionallyUniformProbabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ConditionallyUniformProbabilities(tree::AbstractTree)</code></pre><p>Given a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree for which the probability distribution will be generated</p><p><strong>Example</strong></p><pre><code class="language-none">probs = ConditionallyUniformProbabilities(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L566-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.UniformLeafProbabilities" href="#JuDGE.UniformLeafProbabilities"><code>JuDGE.UniformLeafProbabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">UniformLeafProbabilities(tree::AbstractTree)</code></pre><p>Given a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree for which the probability distribution will be generated</p><p><strong>Example</strong></p><pre><code class="language-none">probs = UniformLeafProbabilities(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L593-L603">source</a></section></article><h3 id="Other-Tree-functions"><a class="docs-heading-anchor" href="#Other-Tree-functions">Other Tree functions</a><a id="Other-Tree-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Tree-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.depth" href="#JuDGE.depth"><code>JuDGE.depth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">depth(tree::AbstractTree)</code></pre><p>Given <code>tree</code>, this function returns the depth. The root node has a depth of 0.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the node we wish to find the depth for.</p><p><strong>Example</strong></p><pre><code class="language-none">depth = JuDGE.depth(tree) #returns the depth of a node in a tree</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L660-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.history" href="#JuDGE.history"><code>JuDGE.history</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">history(tree::AbstractTree)</code></pre><p>Given <code>tree</code>, this function returns the history back up to the root node of <code>tree</code>.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the node that we wish to find the history for.</p><p><strong>Example</strong></p><pre><code class="language-none">history = JuDGE.history(tree) #get a vector of nodes that precede tree</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L676-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.visualize_tree" href="#JuDGE.visualize_tree"><code>JuDGE.visualize_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visualize_tree(some_tree::AbstractTree,
    data::Union{Dict{Symbol,Any},Dict{Symbol,Dict{AbstractTree,Float64}}};
    scale_edges=nothing,
    scale_all=1.0)</code></pre><p>Given <code>some_tree</code>, this function generates a html/js visualization of the tree.</p><p><strong>Required Arguments</strong></p><p><code>some_tree</code> is the tree we wish to visualise.</p><p><code>data</code> is a dictionary of the data we wish to display, each element is another dictionary indexed by the nodes of the tree.</p><p><strong>Optional Arguments</strong></p><p><code>scale_edges</code> this scales the lengths of the arcs.</p><p><code>scale_all</code> this scales the whole network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L217-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.get_groups" href="#JuDGE.get_groups"><code>JuDGE.get_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_groups(tree::AbstractTree; combine=0)</code></pre><p>Given a <code>tree</code>, this function will split it up into an array of subtrees. These can be provided as <code>blocks</code> for the <code>JuDGE.solve()</code> function to perform partial pricing.</p><p><strong>Required Arguments</strong></p><p><code>tree</code> is the tree from which we are finding the node</p><p><strong>Optional Arguments</strong></p><p><code>combine</code> this parameter determines the size of the subtrees (higher creates larger subtrees). If set to 0, the subtrees will be the sets of paths to the leaf nodes.</p><p><strong>Examples</strong></p><pre><code class="language-none">blocks = get_groups(tree)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/tree.jl#L783-L798">source</a></section></article><h2 id="JuDGE-Functions"><a class="docs-heading-anchor" href="#JuDGE-Functions">JuDGE Functions</a><a id="JuDGE-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-Functions" title="Permalink"></a></h2><h3 id="JuDGE-solving-functions"><a class="docs-heading-anchor" href="#JuDGE-solving-functions">JuDGE solving functions</a><a id="JuDGE-solving-functions-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-solving-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.JuDGEModel" href="#JuDGE.JuDGEModel"><code>JuDGE.JuDGEModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JuDGEModel(tree::AbstractTree,
           probabilities,
           sub_problem_builder::Function,
           solver;
           discount_factor=1.0,
           risk=RiskNeutral(),
           sideconstraints=nothing,
           check=true,
           perfect_foresight=false)</code></pre><p>Define a JuDGE model.</p><p><strong>Required arguments</strong></p><p><code>tree</code> is a reference to a scenario tree</p><p><code>probabilities</code> is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself</p><p><code>sub_problem_builder</code> is a function mapping a node to a JuMP model for each subproblems</p><p><code>solver</code> is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)</p><p><strong>Optional arguments</strong></p><p><code>discount_factor</code> is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree</p><p><code>risk</code> can be either a <code>Risk</code> object, or a vector of such objects.</p><p><code>sideconstraints</code> is a function which specifies side constraints in the master problem, see <a href="../tutorials/#Tutorial-9:-Side-constraints">Tutorial 9: Side-constraints</a> for further details</p><p><code>check</code> is a boolean, which can be set to <code>false</code> to disable the validation of the JuDGE model.</p><p><code>perfect_foresight</code> is a boolean; this is an experimental feature, which creates an array of JuDGE models, one for each leaf node. This will enable users to easily compute the EVPI for the stochastic program. Also can be used for regret-based risk implementations.</p><p><strong>Examples</strong></p><pre><code class="language-none">judge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,
                                Gurobi.Optimizer)
judge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,
                                discount_factor=0.9, risk=Risk(0.5,0.1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/JuDGE.jl#L72-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.solve-Tuple{JuDGEModel}" href="#JuDGE.solve-Tuple{JuDGEModel}"><code>JuDGE.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(judge::JuDGEModel;
      termination::Termination=Termination(),
      max_no_int::Int=typemax(Int),
      blocks::Union{Nothing,Array{Array{AbstractTree,1},1}}=nothing,
      warm_starts::Bool=false,
      optimizer_attributes::Union{Nothing,Function}=nothing,
      mp_callback::Union{Nothing,Function}=nothing,
      prune::Float64=Inf,
      heuristic::Union{Nothing,Function}=nothing,
      verbose::Int=2)</code></pre><p>Solve a JuDGEModel <code>judge</code> without branch-and-price.</p><p><strong>Required Arguments</strong></p><p><code>judge</code> is the JuDGE model that we wish to solve.</p><p><strong>Optional Arguments</strong></p><p><code>termination</code> is a <code>Termination</code> object containing all the stopping conditions.</p><p><code>max_no_int</code> is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the <code>relgap</code> / <code>absgap</code> stopping conditions. To override this, set <code>max_no_int</code> to the negative of the number desired value.</p><p><code>blocks</code> specifies the groups of nodes to solve in each iteration (these groups can be generated using <code>JuDGE.get_groups()</code>, or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See <code>advanced.jl</code> for more details.</p><p><code>warm_starts</code> boolean specifing whether to use warm starts for subproblems and binary solves of master problem.</p><p><code>optimizer_attributes</code> can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the <code>advanced.jl</code> example.</p><p><code>mp_callback</code> is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.</p><p><code>prune</code> is used to stop the algorithm before convergence, if a known upper bound for the problem is specified.</p><p><code>heuristic</code> is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.</p><p><code>verbose</code> if 0, all output from solve will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.</p><p><strong>Examples</strong></p><pre><code class="language-none">JuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6))
JuDGE.solve(jmodel, termination=Termination(rlx_abstol=10^-6), max_no_int=-5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/JuDGE.jl#L407-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.branch_and_price" href="#JuDGE.branch_and_price"><code>JuDGE.branch_and_price</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">branch_and_price(models::Union{JuDGEModel,Array{JuDGEModel,1}};
	branch_method::Function=JuDGE.variable_branch,search::Symbol=:lowestLB,
	termination::Termination=Termination(),
	max_no_int::Int=typemax(Int),
	blocks::Union{Nothing,Array{Array{AbstractTree,1},1}}=nothing,
	warm_starts::Bool=false,
	optimizer_attributes::Union{Nothing,Function}=nothing,
	mp_callback::Union{Nothing,Function}=nothing,
	bp_callback::Union{Nothing,Function}=nothing,
	heuristic::Union{Nothing,Function}=nothing,
	verbose::Int=2)</code></pre><p>Solve a JuDGEModel <code>judge</code> without branch and price.</p><p><strong>Required Arguments</strong></p><p><code>judge</code> is the JuDGE model that we wish to solve.</p><p><strong>Optional Arguments</strong></p><p><code>branch_method</code> is a function specifies the way that constraints are added to create new nodes in the branch<em>and</em>price tree.</p><p><code>search</code> specifies the order in which nodes are solved in the (branch-and-price) tree. Options are: <code>:lowestLB</code>, <code>:depth_first_dive</code>, <code>:depth_first_resurface</code>, <code>:breadth_first</code>.</p><p><code>termination</code> is a <code>Termination</code> object containing all the stopping conditions.</p><p><code>max_no_int</code> is the maximum number of iterations yielding a fractional solution before a MIP solve is performed on the master. By default, the MIP solves will not occur until the relaxed bound gap is less than the <code>relgap</code> / <code>absgap</code> stopping conditions. To override this, set <code>max_no_int</code> to the negative of the number desired value.</p><p><code>blocks</code> specifies the groups of nodes to solve in each iteration (these groups can be generated using <code>JuDGE.get_groups()</code>, or created manually), after all nodes have been solved, a full pricing iteration is used to compute an updated lower bound. See <code>advanced.jl</code> for more details.</p><p><code>warm_starts</code> boolean specifing whether to use warm starts for subproblems and binary solves of master problem.</p><p><code>optimizer_attributes</code> can be set to a specific function that dynamically changes optimizer attributes for the subproblems; this should only be used by people who have examined the <code>advanced.jl</code> example.</p><p><code>mp_callback</code> is a user-defined function that specifies termination conditions for MIP solves of the master problem. See examples/advanced.jl.</p><p><code>bp_callback</code> is a user-defined function that allows you to modify the <code>Termination</code> conditions for <code>JuDGE.solve</code> and the <code>search</code> policy during the branch-and-price process.</p><p><code>heuristic</code> is a user-defined function that typically would perform an improvement heuristic when a new incumbent is found.</p><p><code>verbose</code> if 0, most output from <code>JuDGE.solve</code> will be suppressed, if 1, the subproblem solve process will be suppressed. Default is 2.</p><p><strong>Examples</strong></p><pre><code class="language-none">JuDGE.branch_and_price(jmodel, termination=Termination(abstol=10^-6))
JuDGE.branch_and_price(jmodel, search=:depth_first_dive, verbose=0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/branchandprice.jl#L241-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.variable_branch" href="#JuDGE.variable_branch"><code>JuDGE.variable_branch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">variable_branch(jmodel::JuDGEModel, inttol::Float64)</code></pre><p>This is an in-built function that is called during branch-and-price to perform a branch. Users can define their own functions that follow this format to create new branching strategies.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model</p><p><code>inttol</code> is the maximum permitted deviation from binary/integer for a value to still be considered binary/integer feasible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/branchandprice.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.resolve_subproblems" href="#JuDGE.resolve_subproblems"><code>JuDGE.resolve_subproblems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resolve_subproblems(judge::JuDGEModel)</code></pre><p>Once a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model that we wish to solve.</p><p><strong>Examples</strong></p><pre><code class="language-none">resolve_subproblems(judge)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/JuDGE.jl#L950-L960">source</a></section></article><h3 id="JuDGE-macros-for-subproblems"><a class="docs-heading-anchor" href="#JuDGE-macros-for-subproblems">JuDGE macros for subproblems</a><a id="JuDGE-macros-for-subproblems-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-macros-for-subproblems" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@expansion" href="#JuDGE.@expansion"><code>JuDGE.@expansion</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">expansion(model, variable, args...)</code></pre><p>Defines an expansion variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of expansion variables.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the expansion variable to</p><p><code>variable</code> is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>lag</code> is the number of nodes in the scenario between an expansion being decided, and it becoming available.</p><p><code>duration</code> is the number of consecutive nodes in the scenario over which an expansion is available.</p><p><code>lb</code> is the lower bound for this variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for this variable in the master problem (typically omitted).</p><p><strong>Examples</strong></p><pre><code class="language-none">@expansion(model, expand[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan
@expansion(model, expand[1:5,1:2]&gt;=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration
@expansion(model, 0&lt;=expand&lt;=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/macros.jl#L122-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@shutdown" href="#JuDGE.@shutdown"><code>JuDGE.@shutdown</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">shutdown(model, variable, args...)</code></pre><p>Defines an shutdown variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of shutdown variables.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the shutdown variable to</p><p><code>variable</code> is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>lag</code> is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable.</p><p><code>duration</code> is the number of consecutive nodes in the scenario over which the shutdown will last.</p><p><code>lb</code> is the lower bound for this variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for this variable in the master problem (typically omitted).</p><p><strong>Examples</strong></p><pre><code class="language-none">@shutdown(model, shut[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan
@shutdown(model, shut[1:5,1:2]&gt;=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration
@shutdown(model, 0&lt;=shut&lt;=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/macros.jl#L165-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@enforced" href="#JuDGE.@enforced"><code>JuDGE.@enforced</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">enforced(model, variable, args...)</code></pre><p>Defines an enforced variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of enforced variables. These variables can be used as either expansion or shutdown variables, but since the constraint in the master problem is an equality, convergence is more difficult since there is less flexibility when solving the master problem.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the expansion variable to</p><p><code>variable</code> is the name of the variable being created, this will be continuous by default; follows JuMP syntax if defining a set of variables.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>lag</code> is the number of nodes in the scenario between an expansion being decided, and it becoming available.</p><p><code>duration</code> is the number of consecutive nodes in the scenario over which an expansion is available.</p><p><code>lb</code> is the lower bound for this variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for this variable in the master problem (typically omitted).</p><p><code>penalty</code> is a placeholder for a future feature, which may allow the violation of master/subproblem equality constraint, at a cost.</p><p><strong>Examples</strong></p><pre><code class="language-none">@expansion(model, forced[1:5], Bin) #defines an array of 5 binary variables with no lag, and unlimited lifespan
@expansion(model, forced[1:5,1:2]&gt;=0, lag=1) #defines a matrix of 10 continuous variables with a lag of 1, and unlimited duration
@expansion(model, 0&lt;=forced&lt;=10, Int, duration=2) #defines a single integer variable with a lag of 0, and a duration of 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/macros.jl#L208-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@state" href="#JuDGE.@state"><code>JuDGE.@state</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">state(model, variable, args...)</code></pre><p>Defines a state variable <code>variable</code> within a subproblem <code>model</code>. Note that all subproblems must have the same set of state variables. These variables can be used to model inventory that is carried forward between the subproblems.</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem that we are adding the expansion variable to</p><p><code>variable</code> is the name of the variable being created in the subproblem, this will be continuous by default; follows JuMP syntax if defining a set of variables. The subproblem variable corresponds to the change in the state.</p><p><strong>Optional Arguments</strong></p><p>This macro has a third, unnamed, argument which can be set to Con, Bin, or Int, similar to the <code>@variable</code> macro.</p><p><code>state_name</code> is the name for the state variable in the master problem. If omitted, the name of the master problem variable will match the subproblem variable (but this may cause confusion, since only the master problem variable is the state). See the <code>inventory.jl</code> example to see how this should be implemented.</p><p><code>initial</code> is the initial value for the master problem&#39;s state variable at the root node.</p><p><code>lb</code> is the lower bound for the variable in the master problem (typically omitted).</p><p><code>ub</code> is the upper bound for the variable in the master problem (typically omitted).</p><p><strong>Examples</strong></p><pre><code class="language-none">@state(sp, -50&lt;=Δstock&lt;=50, state_name=stock, lb=0, ub=200, initial=0) #defines a state variable called stock in the master
                                                                       #(starting at 0, and able to take values 0 to 200),
                                                                       #and Δstock in the subproblem (able to change the stock level by ±50).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/macros.jl#L255-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@capitalcosts" href="#JuDGE.@capitalcosts"><code>JuDGE.@capitalcosts</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">capitalcosts(model, expr)</code></pre><p>Defines a linear expression specifying the capital cost of expansions and shutdowns at the current node</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for</p><p><code>expr</code> is an <code>AffExpr</code> which gives the total cost of choosing expansion and shutdown variables at the current node</p><p><strong>Example</strong></p><pre><code class="language-none">@capitalcosts(model, sum(expand[i]*cost[node][i] for i in 1:5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/macros.jl#L302-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.@ongoingcosts" href="#JuDGE.@ongoingcosts"><code>JuDGE.@ongoingcosts</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">ongoingcosts(model, expr)</code></pre><p>Defines a linear expression specifying the ongoing costs of expansions and shutdowns available at the current node</p><p><strong>Required Arguments</strong></p><p><code>model</code> is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for</p><p><code>expr</code> is an <code>AffExpr</code> which gives the ongoing cost of expansions and shutdowns available at the current node</p><p><strong>Example</strong></p><pre><code class="language-none">@ongoingcosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/macros.jl#L334-L346">source</a></section></article><h3 id="JuDGE-Output"><a class="docs-heading-anchor" href="#JuDGE-Output">JuDGE Output</a><a id="JuDGE-Output-1"></a><a class="docs-heading-anchor-permalink" href="#JuDGE-Output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}" href="#JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}"><code>JuDGE.write_solution_to_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_solution_to_file(jmodel::JuDGEModel,filename::String)</code></pre><p>Given a JuDGE model and a filename, this function writes the entire solution to a CSV.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model whose solution we wish to write to a file</p><p><code>filename</code> is the output filename</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/output.jl#L464-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.print_expansions-Tuple{JuDGEModel}" href="#JuDGE.print_expansions-Tuple{JuDGEModel}"><code>JuDGE.print_expansions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_expansions(jmodel::JuDGEModel;
                 onlynonzero::Bool=true,
                 inttol=10^-9,
                 format=nothing)</code></pre><p>Given a solved JuDGE model, this function will write the optimal capacity expansion decisions to the REPL.</p><p><strong>Required Arguments</strong></p><p><code>jmodel</code> is the JuDGE model whose solution we wish to write to a file</p><p><strong>Optional Arguments</strong></p><p><code>onlynonzero</code> is a boolean, if set to <code>true</code> the function will only print expansions with a non-zero value.</p><p><code>inttol</code> is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-<code>inttol</code> will be treated as 1</p><p><code>format</code> is a function that specifies customised printing of expansion values. See <a href="../tutorials/#Tutorial-2:-Formatting-output">Tutorial 2: Formatting output</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/output.jl#L21-L42">source</a></section></article><h2 id="Deterministic-Equivalent"><a class="docs-heading-anchor" href="#Deterministic-Equivalent">Deterministic Equivalent</a><a id="Deterministic-Equivalent-1"></a><a class="docs-heading-anchor-permalink" href="#Deterministic-Equivalent" title="Permalink"></a></h2><h3 id="Define-and-solve-DetEq-model"><a class="docs-heading-anchor" href="#Define-and-solve-DetEq-model">Define and solve DetEq model</a><a id="Define-and-solve-DetEq-model-1"></a><a class="docs-heading-anchor-permalink" href="#Define-and-solve-DetEq-model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.DetEqModel" href="#JuDGE.DetEqModel"><code>JuDGE.DetEqModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DetEqModel(tree::AbstractTree,
           probabilities,
           sub_problem_builder::Function,
           solver
           discount_factor=1.0,
           risk=RiskNeutral,
           sideconstraints=nothing,
           parallel=false,
           check=true)</code></pre><p>Define a deterministic equivalent model for the stochastic capacity expansion problem.</p><p><strong>Required arguments</strong></p><p><code>tree</code> is a reference to a scenario tree</p><p><code>probabilities</code> is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself</p><p><code>sub_problem_builder</code> is a function mapping a node to a JuMP model for each subproblems</p><p><code>solver</code> is a reference to the optimizer used for this problem (with appropriate settings)</p><p><strong>Optional arguments</strong></p><p><code>discount_factor</code> is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree</p><p><code>risk</code> is a tuple with the two CVaR parameters: (λ, α)</p><p><code>sideconstraints</code> is a function which specifies side constraints in the master problem, see <a href="../tutorials/#Tutorial-9:-Side-constraints">Tutorial 9: Side-constraints</a> for further details.</p><p><code>parallel</code> is a boolean, setting whether the sub-problems will be formulated in parallel</p><p><code>check</code> is a boolean, which can be set to <code>false</code> to disable the validation of the JuDGE model.</p><p><strong>Examples</strong></p><pre><code class="language-none">deteq = DetEqModel(tree, ConditionallyUniformProbabilities, sub_problems,
                                Gurobi.Optimizer)
judge = DetEqModel(tree, probabilities, sub_problems, CPLEX.Optimizer,
                                discount_factor=0.9, risk=(0.5,0.1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/deteq.jl#L13-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.solve-Tuple{DetEqModel}" href="#JuDGE.solve-Tuple{DetEqModel}"><code>JuDGE.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(deteq::DetEqModel)</code></pre><p>Solve a determinisitc equivalent model.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is the determinisitc equivalent model that we wish to solve.</p><p><strong>Example</strong></p><pre><code class="language-none">JuDGE.solve(deteq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/deteq.jl#L579-L589">source</a></section></article><h3 id="Deterministic-Equivalent-Output"><a class="docs-heading-anchor" href="#Deterministic-Equivalent-Output">Deterministic Equivalent Output</a><a id="Deterministic-Equivalent-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Deterministic-Equivalent-Output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="JuDGE.write_solution_to_file-Tuple{DetEqModel,String}" href="#JuDGE.write_solution_to_file-Tuple{DetEqModel,String}"><code>JuDGE.write_solution_to_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_solution_to_file(deteq::DetEqModel,filename::String)</code></pre><p>Given a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is the deterministic equivalent model whose solution we wish to write to a file</p><p><code>filename</code> is the output filename</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/output.jl#L339-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.print_expansions-Tuple{DetEqModel}" href="#JuDGE.print_expansions-Tuple{DetEqModel}"><code>JuDGE.print_expansions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_expansions(deteq::DetEqModel;
                 onlynonzero::Bool=true,
                 inttol=10^-9,
                 format=nothing)</code></pre><p>Given a solved deterministic equivalent model, this function will write the optimal capacity expansion decisions to the REPL.</p><p><strong>Required Arguments</strong></p><p><code>deteq</code> is the deterministic equivalent model whose solution we wish to write to a file</p><p><strong>Optional Arguments</strong></p><p><code>onlynonzero</code> is a boolean, if set to <code>true</code> the function will only print expansions with a non-zero value.</p><p><code>inttol</code> is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-<code>inttol</code> will be treated as 1</p><p><code>format</code> is a function that specifies customised printing of expansion values. See <a href="../tutorials/#Tutorial-2:-Formatting-output">Tutorial 2: Formatting output</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/output.jl#L162-L183">source</a></section></article><h2 id="Risk"><a class="docs-heading-anchor" href="#Risk">Risk</a><a id="Risk-1"></a><a class="docs-heading-anchor-permalink" href="#Risk" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuDGE.RiskNeutral-Tuple{}" href="#JuDGE.RiskNeutral-Tuple{}"><code>JuDGE.RiskNeutral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RiskNeutral()</code></pre><p>Create a risk-neutral risk measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/risk.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.Risk-Tuple{Float64,Float64}" href="#JuDGE.Risk-Tuple{Float64,Float64}"><code>JuDGE.Risk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Risk(λ::Float64,
     α::Float64;
     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,
     bound::Union{Float64,Nothing}=nothing,
     penalty::Float64=100000.0)</code></pre><p>Define the CVaR risk measure to be applied to the accumulated profits at the leaf nodes.</p><p><strong>Required Arguments</strong></p><p><code>λ</code> is weighting applied for the risk measure (max sum of weightings should be 1.0), if sum of weightings is less than 1.0, expected value will make up the rest.</p><p><code>α</code> is the probability in the tail of the distribution</p><p><strong>Optional Arguments</strong></p><p><code>offset</code> applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.</p><p><code>bound</code> if used, this will create a constraint on CVaR(α) with this as the upper bound.</p><p><code>penalty</code> if a constraint on CVaR is applied, then the marginal cost of violating the constraint is <code>penalty</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/risk.jl#L18-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuDGE.Risk-Tuple{Float64}" href="#JuDGE.Risk-Tuple{Float64}"><code>JuDGE.Risk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Risk(λ::Float64,
     α::Float64;
     offset::Union{Dict{Leaf,Float64},Nothing}=nothing,
     bound::Union{Float64,Nothing}=nothing,
     penalty::Float64=100000.0)</code></pre><p>Define the CVaR risk constraint to be applied to the accumulated profits at the leaf nodes.</p><p><strong>Required Arguments</strong></p><p><code>α</code> is the probability in the tail of the distribution</p><p><strong>Optional Arguments</strong></p><p><code>offset</code> applies a negative offset to each leaf node. This can be used to reorder the outcomes prior to applying the risk measure.</p><p><code>bound</code> if used, this will create a constraint on CVaR(α) with this as the upper bound.</p><p><code>penalty</code> if a constraint on CVaR is applied, then the marginal cost of violating the constraint is <code>penalty</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reganbaucke/JuDGE.jl/blob/867336f3f930bd75f9f8c253a38ea7669908361c/src/risk.jl#L57-L77">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/">« Tutorials</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 10 June 2021 03:00">Thursday 10 June 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
