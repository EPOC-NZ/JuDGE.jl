var documenterSearchIndex = {"docs":
[{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"EditURL = \"https://github.com/reganbaucke/JuDGE.jl/blob/master/docs/src/examples/02-knapsack-branch.jl\"","category":"page"},{"location":"examples/02-knapsack-branch/#Knapsack-Problem-Branch-and-Price","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"This example demonstrates how the branch and price algorithm can be used to solve a JuDGE model.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"using JuMP, JuDGE, GLPK, Random","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"We will randomly generate data for this problem, but to ensure a consistent result we first set the random seed.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Random.seed!(50)","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"We specify that there are 5 possible expansion investments, and 10 items to select from at each node.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"numinvest = 5\nnumitems = 10","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"The tree is defined to have a depth and 4 and a degree of 3.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"mytree = narytree(4,3)","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Find the number of nodes in the tree","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"totalnodes = JuDGE.count(mytree)","category":"page"},{"location":"examples/02-knapsack-branch/#Data","page":"Knapsack Problem - Branch and Price","title":"Data","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up the investment cost data","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"investcost = zeros(totalnodes,numinvest)\nfor i = 1:totalnodes\n  investcost[i,:] = ([1,1.8,3.5,6.8,13.5])*(1-((i-1)/(totalnodes*1.2)))\nend","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Specify the investment volumes using a binary expansion, with an initial capacity of 0","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"investvol = [1,2,4,8,16]\ninitialcap = 0","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Randomly specify the item volumes and costs","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"itemvolume = zeros(totalnodes,numitems)\nfor i = 1:totalnodes\n  itemvolume[i,:] = ((rand(numitems))*2) + collect(range(4,22,length = numitems))\nend\n\nitemcost = zeros(totalnodes,numitems)\nfor i = 1:totalnodes\n  itemcost[i,:] = ((rand(numitems) .- 0.5)*2)*2# + collect(range(0.5,1,length = numitems))\nend","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Create a function that maps the node, and data name to a value","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"nodes = collect(mytree)\nfunction data(node, input)\n  input[findall(x -> x == node, nodes)[1], :]\nend","category":"page"},{"location":"examples/02-knapsack-branch/#Subproblem-definitions","page":"Knapsack Problem - Branch and Price","title":"Subproblem definitions","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Define the subproblems as a function of the node","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"JuDGE_SP_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0, \"mip_gap\" => 0.0)\nfunction sub_problems(node)\n  model = Model(JuDGE_SP_Solver)\n  @expansion(model, bag[1:numinvest])\n  @expansioncosts(model, sum(data(node,investcost)[i] * bag[i] for i in  1:numinvest))\n  @variable(model, y[1:numitems], Bin)\n  @constraint(model, BagExtension ,sum( y[i]*data(node,itemvolume)[i] for i in 1:numitems) <=\n  \t\t\t\tinitialcap + sum(bag[i]*investvol[i] for i in 1:numinvest))\n  @sp_objective(model, sum(-data(node,itemcost)[i] * y[i] for i in 1:numitems))\n  model\nend","category":"page"},{"location":"examples/02-knapsack-branch/#Defining-and-solving-the-JuDGE-model","page":"Knapsack Problem - Branch and Price","title":"Defining and solving the JuDGE model","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up the JuDGE model.","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"JuDGE_MP_Solver = optimizer_with_attributes((method=GLPK.INTERIOR) -> GLPK.Optimizer(),\n\t\t\t\t\t\t\t\"msg_lev\" => 0, \"mip_gap\" => 0.0)\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Solve the JuDGE model using the branch and price algorithm, using a constraint branch and branching on the lowest lower bound nodes first","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"best=JuDGE.branch_and_price(judy,rlx_abstol=10^-7,inttol=10^-6,\n\t\t\t\tbranch_method=JuDGE.constraint_branch,search=:lowestLB)","category":"page"},{"location":"examples/02-knapsack-branch/#Displaying-the-output","page":"Knapsack Problem - Branch and Price","title":"Displaying the output","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Print the objective function value","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"println(\"Objective: \"*string(best.bounds.UB))","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Create a custom function that formats the output for print_expansions(...), and print the expansions using this function","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"function format_output(s::Symbol,values)\n  if s==:bag\n\t return sum(values[i]*investvol[i] for i in 1:numinvest)\n  end\n  return nothing\nend\n\nJuDGE.print_expansions(best,format=format_output)","category":"page"},{"location":"examples/02-knapsack-branch/#Deterministic-equivalent","page":"Knapsack Problem - Branch and Price","title":"Deterministic equivalent","text":"","category":"section"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"Set up and solve the deterministic equivalent problem","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"JuDGE_DE_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 2, \"mip_gap\" => 3)\ndeteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)\nprintln(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"","category":"page"},{"location":"examples/02-knapsack-branch/","page":"Knapsack Problem - Branch and Price","title":"Knapsack Problem - Branch and Price","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"EditURL = \"https://github.com/reganbaucke/JuDGE.jl/blob/master/docs/src/examples/01-knapsack-1bag.jl\"","category":"page"},{"location":"examples/01-knapsack-1bag/#Knapsack-Problem-Single-Expansion","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This first example demonstrates how a basic JuDGE model can be set up, with a 7-node tree, and a single expansion.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"using JuMP, JuDGE, GLPK","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"First we will define our tree with a depth of 2 and a degree of 2.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"mytree = narytree(2,2)","category":"page"},{"location":"examples/01-knapsack-1bag/#Data","page":"Knapsack Problem - Single Expansion","title":"Data","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Now we specify data for each node of the tree. Here we define the data using functions, but you could use dictionaries, as shown in subsequent examples.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"function invest_cost(node)\n   if node == get_node(mytree,[1])\n\t  180.0\n   elseif node == get_node(mytree,[1,1])\n\t  50.0\n   elseif node == get_node(mytree,[1,2])\n\t  60.0\n   elseif node == get_node(mytree,[1,1,1])\n\t  40.0\n   elseif node == get_node(mytree,[1,1,2])\n\t  60.0\n   elseif node == get_node(mytree,[1,2,1])\n\t  10.0\n   elseif node == get_node(mytree,[1,2,2])\n\t  10.0\n   end\nend\n\nfunction item_volume(node)\n   if node == get_node(mytree,[1])\n\t  [6, 2, 1, 1, 1]\n   elseif node == get_node(mytree,[1,1])\n\t  [8, 2, 2, 2, 1]\n   elseif node == get_node(mytree,[1,2])\n\t  [8, 1, 1, 1, 3]\n   elseif node == get_node(mytree,[1,1,1])\n\t  [4, 4, 3, 1, 2]\n   elseif node == get_node(mytree,[1,1,2])\n\t  [1, 3, 1, 1, 2]\n   elseif node == get_node(mytree,[1,2,1])\n\t  [7, 3, 1, 1, 1]\n   elseif node == get_node(mytree,[1,2,2])\n\t  [2, 5, 2, 1, 2]\n   end\nend\n\nfunction item_reward(node)\n   if node == get_node(mytree,[1])\n\t  [60, 20, 10, 15, 10]\n   elseif node == get_node(mytree,[1,1])\n\t  [8, 10, 20, 20, 10]\n   elseif node == get_node(mytree,[1,2])\n\t  [8, 10, 15, 10, 30]\n   elseif node == get_node(mytree,[1,1,1])\n\t  [40, 40, 35, 10, 20]\n   elseif node == get_node(mytree,[1,1,2])\n\t  [15, 35, 15, 15, 20]\n   elseif node == get_node(mytree,[1,2,1])\n\t  [70, 30, 15, 15, 10]\n   elseif node == get_node(mytree,[1,2,2])\n\t  [25, 50, 25, 15, 20]\n   end\nend","category":"page"},{"location":"examples/01-knapsack-1bag/#Subproblem-definitions","page":"Knapsack Problem - Single Expansion","title":"Subproblem definitions","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"The JuDGE subproblems are defined through a function that takes a node as its single argument, returning a JuMP model. We use GLPK as our optimizer.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE_SP_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 0, \"mip_gap\" => 0.0)\nfunction sub_problems(node)\n   model = Model(JuDGE_SP_Solver)\n   @expansion(model, bag)\n   @expansioncosts(model, bag*invest_cost(node))\n   @variable(model, y[1:5], Bin)\n   @constraint(model, BagExtension, sum(y[i]*item_volume(node)[i] for i in 1:5) <= 3 + 4 * bag)\n   @sp_objective(model, sum(-item_reward(node)[i] * y[i] for i in 1:5))\n   model\nend","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Note that there are a few JuDGE-specific macros used to define a JuDGE subproblem","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This defines our single expansion variable","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@expansion(model, bag)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This defines the cost of buying this bag at particular node","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@expansioncosts(model, bag*invest_cost(node))","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Instead of using @objective, JuDGE models use:","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"@sp_objective(model, sum(-item_reward(node)[i] * y[i] for i in 1:5))","category":"page"},{"location":"examples/01-knapsack-1bag/#Defining-and-solving-the-JuDGE-model","page":"Knapsack Problem - Single Expansion","title":"Defining and solving the JuDGE model","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"The JuDGEModel is defined based on a tree, probability distribution, sub_problems, and an optimizer using an interior point method.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE_MP_Solver = optimizer_with_attributes((method=GLPK.INTERIOR) -> GLPK.Optimizer(),\n\t\t\t\t\t\t\t\"msg_lev\" => 0, \"mip_gap\" => 0.0)\njudy = JuDGEModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_MP_Solver)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Solve the model","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE.solve(judy)","category":"page"},{"location":"examples/01-knapsack-1bag/#Displaying-the-output","page":"Knapsack Problem - Single Expansion","title":"Displaying the output","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Print the objective, and optimal expansions","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"println(\"Objective: \"*string(judy.bounds.UB))\nJuDGE.print_expansions(judy,onlynonzero=false)","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Re-solve the subproblems and print the objective","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"println(\"Re-solved Objective: \" * string(resolve_subproblems(judy)))","category":"page"},{"location":"examples/01-knapsack-1bag/#Deterministic-equivalent","page":"Knapsack Problem - Single Expansion","title":"Deterministic equivalent","text":"","category":"section"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"Here we set up and solve the deterministic equivalent, this uses the same structure as a JuDGEModel. We set up our GLPK solver to show its progress.","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"JuDGE_DE_Solver = optimizer_with_attributes(GLPK.Optimizer, \"msg_lev\" => 2, \"mip_gap\" => 0.0)\ndeteq = DetEqModel(mytree, ConditionallyUniformProbabilities, sub_problems, JuDGE_DE_Solver)\nJuDGE.solve(deteq)\nprintln(\"Deterministic Equivalent Objective: \" * string(objective_value(deteq.problem)))","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"","category":"page"},{"location":"examples/01-knapsack-1bag/","page":"Knapsack Problem - Single Expansion","title":"Knapsack Problem - Single Expansion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"judge/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"judge/#JuDGE-Functions","page":"API Reference","title":"JuDGE Functions","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.JuDGEModel\nJuDGE.solve(::JuDGEModel)\nJuDGE.resolve_subproblems","category":"page"},{"location":"judge/#JuDGE.JuDGEModel","page":"API Reference","title":"JuDGE.JuDGEModel","text":"JuDGEModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor::Float64,\n           CVaR::Tuple{Float64,Float64},\n           sideconstraints)\n\nDefine a JuDGE model.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for the master problem (with appropriate settings);  this can also be a tuple containing two optimizers (one for solving the relaxation, and one for  solving the binary model)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nCVaR is a tuple with the two CVaR parameters: (λ, β)\n\nsideconstraints is a function which specifies side constraints in the master problem, see example * for further details.\n\nExamples\n\njudge = JuDGEModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = JuDGEModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, CVaR=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"judge/#JuDGE.solve-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(judge::JuDGEModel;\n      abstol = 10^-14,\n      reltol = 10^-14,\n      rlx_abstol = 10^-14,\n      rlx_reltol = 10^-14,\n      duration = Inf,\n      iter = 2^63 - 1,\n      inttol = 10^-9,\n      allow_frac = 0,\n      prune = Inf)\n\nSolve a JuDGEModel judge without branch and price.\n\nRequired Arguments\n\njudge is the JuDGE model that we wish to solve.\n\nOptional Arguments\n\nabstol is the absolute tolerance for the best integer-feasible objective value and the lower bound\n\nreltol is the relative tolerance for the best integer-feasible objective value and the lower bound\n\nrlx_abstol is the absolute tolerance for the relaxed master objective value and the lower bound\n\nrlx_reltol is Set the relative tolerance for the relaxed master objective value and the lower bound\n\nduration is the maximum duration\n\niter is the maximum number of iterations\n\ninttol is the maximum deviation from 0 or 1 for integer feasible solutions\n\nUsed by the branch and price algorithm\n\nallow_frac indicates wheither a fractional solution will be returned\n\nprune is used to stop the algorithm before convergence, if a known upper bound for the problem is specified\n\nExamples\n\nJuDGE.solve(jmodel, rlx_abstol=10^-6)\nJuDGE.solve(jmodel, abstol=10^-6)\n\n\n\n\n\n","category":"method"},{"location":"judge/#JuDGE.resolve_subproblems","page":"API Reference","title":"JuDGE.resolve_subproblems","text":"resolve_subproblems(judge::JuDGEModel)\n\nOnce a JuDGE model has converged, it is necessary to re-solve the subproblems to find the optimal decisions within each node.\n\nRequired Arguments\n\njmodel is the JuDGE model that we wish to solve.\n\nExamples\n\nresolve_subproblems(judge)\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE-macros-for-subproblems","page":"API Reference","title":"JuDGE macros for subproblems","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.@expansion\nJuDGE.@shutdown\nJuDGE.@expansioncosts\nJuDGE.@maintenancecosts\nJuDGE.@sp_objective","category":"page"},{"location":"judge/#JuDGE.@expansion","page":"API Reference","title":"JuDGE.@expansion","text":"expansion(model, variable, lag, span)\n\nDefines an expansion variable variable within a subproblem model. Note that all subproblems must have the same set of expansion variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the expansion variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an expansion being decided, and it becoming available\n\nspan is the number of consecutive nodes in the scenario over which an expansion is available\n\nExamples\n\n@expansion(model, expand[1:5]) #defines an array of 5 variables with no lag, and unlimited lifespan\n@expansion(model, expand[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited lifespan\n@expansion(model, expand, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"judge/#JuDGE.@shutdown","page":"API Reference","title":"JuDGE.@shutdown","text":"shutdown(model, variable, lag, span)\n\nDefines an shutdown variable variable within a subproblem model. Note that all subproblems must have the same set of shutdown variables.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem that we are adding the shutdown variable to\n\nvariable is the name of the variable being created, this will be automatically set to be binary; follows JuMP syntax if defining a set of variables.\n\nOptional Arguments\n\nlag is the number of nodes in the scenario between an shutdown being decided, and it becoming unavailable\n\nspan is the number of consecutive nodes in the scenario over which the shutdown will last\n\nExamples\n\n@shutdown(model, shut[1:5]) #defines an array of 5 variables with no lag, and unlimited duration\n@shutdown(model, shut[1:5,1:2], 1) #defines a matrix of 10 variables with a lag of 1, and unlimited duration\n@shutdown(model, shut, 0, 2) #defines a single variable with a lag of 0, and a lifespan of 2\n\n\n\n\n\n","category":"macro"},{"location":"judge/#JuDGE.@expansioncosts","page":"API Reference","title":"JuDGE.@expansioncosts","text":"expansioncosts(model, expr)\n\nDefines a linear expression specifying the cost of expansions and shutdowns at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the total cost of choosing expansion and shutdown variables at the current node\n\nExample\n\n@expansioncosts(model, sum(expand[i]*cost[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"judge/#JuDGE.@maintenancecosts","page":"API Reference","title":"JuDGE.@maintenancecosts","text":"maintenancecosts(model, expr)\n\nDefines a linear expression specifying the ongoing cost of expansions and shutdowns available at the current node\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the ongoing cost of expansions and shutdowns available at the current node\n\nExample\n\n@maintenancecosts(model, sum(expand[i]*ongoingcosts[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"judge/#JuDGE.@sp_objective","page":"API Reference","title":"JuDGE.@sp_objective","text":"sp_objective(model, expr)\n\nDefines a linear expression specifying the cost of operating the system for the current node, excluding expansion or ongoing costs.\n\nIf it's possible to avoid costs by not using some previously expanded capacity, this can be included here with by directly including the expansion variable in the expression.\n\nRequired Arguments\n\nmodel is the JuDGE subproblem corresponding to the node in the scenario tree that we are adding specifying the costs for\n\nexpr is an AffExpr which gives the subproblem costs.\n\nExample\n\n@sp_objective(model, sum(y[i]*c[node][i] for i in 1:5))\n\n\n\n\n\n","category":"macro"},{"location":"judge/#Deterministic-Equivalent","page":"API Reference","title":"Deterministic Equivalent","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.DetEqModel\nJuDGE.solve(::DetEqModel)","category":"page"},{"location":"judge/#JuDGE.DetEqModel","page":"API Reference","title":"JuDGE.DetEqModel","text":"DetEqModel(tree::AbstractTree,\n           probabilities,\n           sub_problem_builder::Function,\n           solver;\n           discount_factor::Float64,\n           CVaR::Tuple{Float64,Float64},\n           sideconstraints)\n\nDefine a deterministic equivalent model for the stochastic capacity expansion problem.\n\nRequired arguments\n\ntree is a reference to a scenario tree\n\nprobabilities is either a function, which returns a dictionary of the probabilities of all nodes in a tree, or simply the dictionary itself\n\nsub_problem_builder is a function mapping a node to a JuMP model for each subproblems\n\nsolver is a reference to the optimizer used for this problem (with appropriate settings)\n\nOptional arguments\n\ndiscount_factor is a number between 0 and 1 defining a constant discount factor along each arc in the scenario tree\n\nCVaR is a tuple with the two CVaR parameters: (λ, β)\n\nsideconstraints is a function which specifies side constraints in the master problem, see example * for further details.\n\nExamples\n\ndeteq = DetEqModel(tree, ConditionallyUniformProbabilities, sub_problems,\n                                Gurobi.Optimizer)\njudge = DetEqModel(tree, probabilities, sub_problems, CPLEX.Optimizer,\n                                discount_factor=0.9, CVaR=(0.5,0.1)))\n\n\n\n\n\n","category":"type"},{"location":"judge/#JuDGE.solve-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.solve","text":"solve(deteq::DetEqModel)\n\nSolve a determinisitc equivalent model.\n\nRequired Arguments\n\ndeteq is the determinisitc equivalent model that we wish to solve.\n\nExample\n\nJuDGE.solve(deteq)\n\n\n\n\n\n","category":"method"},{"location":"judge/#JuDGE-Output","page":"API Reference","title":"JuDGE Output","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.write_solution_to_file(::JuDGEModel,::String)\nJuDGE.print_expansions(::JuDGEModel)","category":"page"},{"location":"judge/#JuDGE.write_solution_to_file-Tuple{JuDGEModel,String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(jmodel::JuDGEModel,filename::String)\n\nGiven a JuDGE model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"judge/#JuDGE.print_expansions-Tuple{JuDGEModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(jmodel::JuDGEModel;\n                onlynonzero::Bool=true,\n                inttol=10^-9,\n                format=nothing)\n\nGiven a solved JuDGE model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\njmodel is the JuDGE model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See the examples for more details.\n\n\n\n\n\n","category":"method"},{"location":"judge/#Deterministic-Equivalent-Output","page":"API Reference","title":"Deterministic Equivalent Output","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.write_solution_to_file(::DetEqModel,::String)\nJuDGE.print_expansions(::DetEqModel)","category":"page"},{"location":"judge/#JuDGE.write_solution_to_file-Tuple{DetEqModel,String}","page":"API Reference","title":"JuDGE.write_solution_to_file","text":"write_solution_to_file(deteq::DetEqModel,filename::String)\n\nGiven a deterministic equivalent model and a filename, this function writes the entire solution to a CSV.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nfilename is the output filename\n\n\n\n\n\n","category":"method"},{"location":"judge/#JuDGE.print_expansions-Tuple{DetEqModel}","page":"API Reference","title":"JuDGE.print_expansions","text":"print_expansions(deteq::DetEqModel;\n                onlynonzero::Bool=true,\n                inttol=10^-9,\n                format=nothing)\n\nGiven a solved deterministic equivalent model, this function will write the optimal capacity expansion decisions to the REPL.\n\nRequired Arguments\n\ndeteq is the deterministic equivalent model whose solution we wish to write to a file\n\nOptional Arguments\n\nonlynonzero is a boolean, if set to true the function will only print expansions with a non-zero value.\n\ninttol is the integrality tolerance; any expansion variable value less than this will be treated as 0, and any value greater than 1-inttol will be treated as 1\n\nformat is a function that specifies customised printing of expansion values. See the examples for more details.\n\n\n\n\n\n","category":"method"},{"location":"judge/#AbstractTree-Functions","page":"API Reference","title":"AbstractTree Functions","text":"","category":"section"},{"location":"judge/#Defining-Trees","page":"API Reference","title":"Defining Trees","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.narytree\nJuDGE.tree_from_file\nJuDGE.tree_from_leaves\nJuDGE.print_tree","category":"page"},{"location":"judge/#JuDGE.narytree","page":"API Reference","title":"JuDGE.narytree","text":"narytree(depth::Int64, degree::Int64)\n\nGiven the depth and degree, this function returns an N-ary tree. Note that a depth of 0 return a single Leaf node (which is also the root node of the tree).\n\nRequired Arguments\n\ndepth is the maximum number of arcs from the root node any Leaf node\n\ndegree is the number of children of all nodes, other than the Leaf nodes\n\nExample\n\ntree = narytree(2,2)\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.tree_from_file","page":"API Reference","title":"JuDGE.tree_from_file","text":"tree_from_file(filename::String)\n\nConstruct tree from a file, each line in the file is of the form B,A,... representing an arc in the tree, from node \"A\" to node \"B\". The total number of columns is arbitrary. The first row of the file should be n,p,... these column headers are converted into symbols used to index the data. Each column itself converted into a dictionary, indexed by the node.\n\nRequired Arguments\n\nstring is the full path of the file containing the tree\n\nExample\n\ntree, data = tree_from_file(joinpath(@__DIR__,\"tree.csv\"))\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.tree_from_leaves","page":"API Reference","title":"JuDGE.tree_from_leaves","text":"tree_from_leaves(leafnodes::Array{Array{Int64,1},1}, probs::Array{Float64,1})\n\nConstruct tree from Array of leaf nodes, and (optionally) the corresponding probabilities\n\nRequired Arguments\n\nleafnodes is an array of arrays defining the set of leaf nodes\n\nOptional Arguments\n\nprobs is an array of probabilities for the leaf nodes\n\nExample\n\n(tree,prob) = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]],[0.25,0.25,0.25,0.25])\ntree = tree_from_leaves([[1,1,1],[1,1,2],[1,2,1],[1,2,2]])\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.print_tree","page":"API Reference","title":"JuDGE.print_tree","text":"print_tree(some_tree::AbstractTree, data::Dict{AbstractTree,Float64})\n\nGiven some_tree, this function prints a simple representation of the tree to the REPL.\n\nRequired Arguments\n\nsome_tree is the tree we wish to visualise\n\nOptional Arguments\n\ndata is a dictionary indexed by the nodes of some_tree\n\n\n\n\n\n","category":"function"},{"location":"judge/#Nodes-of-Trees","page":"API Reference","title":"Nodes of Trees","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"Base.collect\nJuDGE.get_leafnodes\nJuDGE.get_node","category":"page"},{"location":"judge/#Base.collect","page":"API Reference","title":"Base.collect","text":"collect(tree::Tree;order=:depth)\n\nGiven tree, this function returns an array of corresponding nodes. By default this will be in a depth-first order.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect the nodes\n\nOptional Arguments\n\norder can be set to :depth or :breadth to specify the order that the nodes are listed in the array.\n\nExamples\n\nnodes = collect(tree) #gets an array of nodes from tree in depth-first order\nnodes = collect(tree,order=:breadth) #gets an array of nodes from tree in breadth-first order\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.get_leafnodes","page":"API Reference","title":"JuDGE.get_leafnodes","text":"get_leafnodes(tree::AbstractTree)\n\nGiven tree, this function returns an array of corresponding Leaf nodes.\n\nRequired Arguments\n\ntree is the tree from which we wish to collect leaf nodes\n\nExample\n\nleafnodes = JuDGE.get_leafnodes(tree) #define a function that returns the parent of each node in the tree\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.get_node","page":"API Reference","title":"JuDGE.get_node","text":"get_node(tree::AbstractTree, indices::Array{Int64,1})\n\nGiven a tree, and an array of indices, this function returns the corresponding node in the tree.\n\nRequired Arguments\n\ntree is the tree from which we are finding the node\n\nindicies is an array of integer indices identifying a node within tree.\n\nExamples\n\nnode = get_node(tree,[1]) #get the root node\nnode = get_node(tree,[1,1]) #get the first child of the root node\nnode = get_node(tree,[1,2]) #get the second child of the root node\n\n\n\n\n\n","category":"function"},{"location":"judge/#Tree-Probabilities","page":"API Reference","title":"Tree Probabilities","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.convert_probabilities\nJuDGE.ConditionallyUniformProbabilities\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"judge/#JuDGE.convert_probabilities","page":"API Reference","title":"JuDGE.convert_probabilities","text":"convert_probabilities(tree::AbstractTree, probabilities::Dict{AbstractTree,Float64})\n\nGiven a dictionary of conditional probabilities for each node in tree, this function returns a dictionary that maps each node of tree to the corresponding unconditional probability.\n\nRequired Arguments\n\ntree is the tree that the probabilities pertain to\n\nprobabilities is a dictionary of condition probabilities for each node in tree\n\nExample\n\nprobs = JuDGE.convert_probabilities(tree,probabilities)\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.ConditionallyUniformProbabilities","page":"API Reference","title":"JuDGE.ConditionallyUniformProbabilities","text":"ConditionallyUniformProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there are conditionally uniform probabilities over the children of any node.\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = ConditionallyUniformProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.UniformLeafProbabilities","page":"API Reference","title":"JuDGE.UniformLeafProbabilities","text":"UniformLeafProbabilities(tree::AbstractTree)\n\nGiven a tree, this function returns a dictionary which maps nodes of the tree to probabilities, given that there is a uniform distribution over the leaf nodes\n\nRequired Arguments\n\ntree is the tree for which the probability distribution will be generated\n\nExample\n\nprobs = UniformLeafProbabilities(tree)\n\n\n\n\n\n","category":"function"},{"location":"judge/#Other-Tree-functions","page":"API Reference","title":"Other Tree functions","text":"","category":"section"},{"location":"judge/","page":"API Reference","title":"API Reference","text":"JuDGE.depth\nJuDGE.history\nJuDGE.parent_builder","category":"page"},{"location":"judge/#JuDGE.depth","page":"API Reference","title":"JuDGE.depth","text":"depth(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a subtree of tree and returns that subtree's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\ndepth_fn = JuDGE.history(tree) #define a function that returns the depth of each node in the tree\ndpth = depth_fn(node) #get the depth of node in tree\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.history","page":"API Reference","title":"JuDGE.history","text":"history(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's history back up to the root node of tree.\n\nRequired Arguments\n\ntree is the tree that the history function will correspond to.\n\nExample\n\nhistory_fn = JuDGE.history(tree) #define a function that returns the history of each node in the tree\n\npast = history_fn(node) #get a vector of nodes that precede node in tree\n\n\n\n\n\n","category":"function"},{"location":"judge/#JuDGE.parent_builder","page":"API Reference","title":"JuDGE.parent_builder","text":"parent_builder(tree::AbstractTree)\n\nGiven tree, this function returns a function that takes a node of tree and returns that node's parent.\n\nRequired Arguments\n\ntree is the tree that the parent function will correspond to.\n\nExample\n\nparent_fn = JuDGE.parent_builder(tree) #define a function that returns the parent of each node in the tree\np = parent_fn(node) #get the parent of node\n\n\n\n\n\n","category":"function"},{"location":"tree/#AbstractTree-API","page":"AbstractTree API","title":"AbstractTree API","text":"","category":"section"},{"location":"tree/#Defining-Trees","page":"AbstractTree API","title":"Defining Trees","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.narytree\nJuDGE.tree_from_file\nJuDGE.tree_from_leaves\nJuDGE.print_tree","category":"page"},{"location":"tree/#Nodes-of-Trees","page":"AbstractTree API","title":"Nodes of Trees","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"Base.collect\nJuDGE.get_leafnodes\nJuDGE.get_node","category":"page"},{"location":"tree/#Tree-Probabilities","page":"AbstractTree API","title":"Tree Probabilities","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.convert_probabilities\nJuDGE.ConditionallyUniformProbabilities\nJuDGE.UniformLeafProbabilities","category":"page"},{"location":"tree/#Other-Tree-functions","page":"AbstractTree API","title":"Other Tree functions","text":"","category":"section"},{"location":"tree/","page":"AbstractTree API","title":"AbstractTree API","text":"JuDGE.depth\nJuDGE.history\nJuDGE.parent_builder","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"CurrentModule = JuDGE\nDocTestSetup = quote\n    using JuDGE\nend","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"(Image: JuDGE)","category":"page"},{"location":"#JuDGE","page":"JuDGE","title":"JuDGE","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE stands for: Julia Decomposition for General Expansion. Functionally, it is a solver which leverages the syntax of the JuMP modelling language to solve a particular class of optimisation problems.","category":"page"},{"location":"#Problem-Class-/-Decomposition","page":"JuDGE","title":"Problem Class / Decomposition","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE solves multi-stage stochastic integer programming problems using Dantzig-Wolfe decomposition. The user must specify a tree that represents the uncertainty of the problem, and at each node define a subproblem that can be a linear or integer program. Further, the expansion variables which link the subproblems must be declared.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE automatically generates a master problem and performs column generation to converge to an optimal solution.","category":"page"},{"location":"#Stochastic-Knapsack-Example","page":"JuDGE","title":"Stochastic Knapsack Example","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is distributed with an example of a multi-stage stochastic integer programming problem. This is a stochastic knapsack problem with investment. The file knapsack.jl contains the implementation of this problem within the JuDGE framework. There are also a number of variants of this model demonstrating other features of JuDGE.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"See the examples for details about this.","category":"page"},{"location":"#Limitations","page":"JuDGE","title":"Limitations","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"For each expansion variable, there can only be one expansion (i.e. variable is binary).\nSupport for decisions to reduce capacity is not fully tested.","category":"page"},{"location":"#Requirements","page":"JuDGE","title":"Requirements","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE requires Julia-1.3+, JuMP and appropriate optimiser(s). For academics, Gurobi / CPLEX provide free academic licenses, otherwise, you can use CBC/Clp or GLPK.","category":"page"},{"location":"#Installation","page":"JuDGE","title":"Installation","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"JuDGE is installed by the Pkg utility provided by Julia. In the Julia REPL, simply make the following function call.","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"] add \"https://github.com/reganbaucke/JuDGE.jl\"","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Then, in your Julia script, use","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"using JuDGE","category":"page"},{"location":"","page":"JuDGE","title":"JuDGE","text":"to import the functions from the JuDGE module into the current namespace.","category":"page"},{"location":"#Bugs","page":"JuDGE","title":"Bugs","text":"","category":"section"},{"location":"","page":"JuDGE","title":"JuDGE","text":"Please raise an issue if you experience an error while using JuDGE.","category":"page"}]
}
